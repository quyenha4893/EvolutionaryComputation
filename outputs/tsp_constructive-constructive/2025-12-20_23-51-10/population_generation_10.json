[
     {
          "algorithm": "This algorithm constructs a TSP tour using a greedy approach, always selecting the closest unvisited node from the current position. It iteratively extends the path by identifying the node with the minimum distance from the current one within the set of unvisited nodes. The process concludes by returning to the specified destination node once all other nodes have been visited.",
          "thought": "The algorithm constructs the tour by iteratively adding the closest unvisited node to the current path until all nodes are visited, then returns to the starting node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node to visit based on a constructive heuristic (nearest neighbor).\n    \n    Args:\n        current_node (int): The index of the node currently at.\n        destination_node (int): The index of the final node to return to (usually the starting node).\n        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.\n        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the \n                                         distance from node i to node j.\n    \n    Returns:\n        int: The index of the next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, the next step is to return to the destination node.\n        return destination_node\n\n    min_distance = float('inf')\n    next_node = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node by performing a two-step lookahead for each unvisited candidate. It calculates a combined cost for each candidate: the direct distance from the current node to the candidate, plus the minimum possible distance from that candidate to any other remaining unvisited node or the final destination. The algorithm then chooses the candidate that minimizes this total combined cost, prioritizing immediate gains while considering the best subsequent immediate step.",
          "thought": "This algorithm selects the next node by evaluating each unvisited candidate based on the sum of its direct distance from the current node and the minimum possible distance from that candidate to any other remaining unvisited node or the final destination, aiming to minimize this combined two-step path cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node to visit based on a constructive heuristic that considers\n    the immediate step and the best possible next step from that candidate.\n    \n    Args:\n        current_node (int): The index of the node currently at.\n        destination_node (int): The index of the final node to return to (usually the starting node).\n        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.\n        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the \n                                         distance from node i to node j.\n    \n    Returns:\n        int: The index of the next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, the next step is to return to the destination node.\n        return destination_node\n\n    min_total_path_extension_cost = float('inf')\n    next_node = -1\n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Cost to reach the candidate node from the current position\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Step 2: Minimum cost to move from the candidate node to any other *remaining* unvisited node,\n        # or back to the destination node if the candidate is the last unvisited node.\n        \n        remaining_nodes_after_candidate = unvisited_nodes - {candidate_node}\n        \n        min_cost_from_candidate_to_future = float('inf')\n\n        if not remaining_nodes_after_candidate:\n            # If candidate_node is the only unvisited node left, the next step after it is the destination.\n            min_cost_from_candidate_to_future = distance_matrix[candidate_node][destination_node]\n        else:\n            # Otherwise, find the minimum distance from candidate_node to any other remaining unvisited node.\n            for future_node in remaining_nodes_after_candidate:\n                min_cost_from_candidate_to_future = min(\n                    min_cost_from_candidate_to_future, \n                    distance_matrix[candidate_node][future_node]\n                )\n        \n        # Calculate the total path extension cost for this candidate:\n        # current_node -> candidate_node -> best_future_node (or destination)\n        total_path_extension_cost = cost_to_candidate + min_cost_from_candidate_to_future\n        \n        # Update if this candidate offers a better two-step path extension cost\n        if total_path_extension_cost < min_total_path_extension_cost:\n            min_total_path_extension_cost = total_path_extension_cost\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next unvisited node by minimizing the sum of the immediate travel cost from the current node and the maximum distance from that candidate node to any subsequent unvisited node or the final destination. This approach balances immediate proximity with preventing the creation of extremely long future path segments, aiming to smooth out the overall route.",
          "thought": "The algorithm selects the next unvisited node by minimizing the sum of the direct travel cost from the current node and the maximum distance from that candidate node to any other remaining unvisited node (or the final destination if no other unvisited nodes remain), aiming to avoid creating extremely remote future stops.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node to visit based on a constructive heuristic that minimizes\n    the sum of the immediate travel cost and the maximum distance to any remaining future node.\n    \n    Args:\n        current_node (int): The index of the node currently at.\n        destination_node (int): The index of the final node to return to (usually the starting node).\n        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.\n        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the \n                                         distance from node i to node j.\n    \n    Returns:\n        int: The index of the next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, the next step is to return to the destination node.\n        return destination_node\n\n    # If only one unvisited node left, it must be the next node\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    min_heuristic_cost = float('inf')\n    next_node = -1\n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Cost to reach the candidate node from the current position\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Step 2: Maximum cost to move from the candidate node to any other *remaining* unvisited node,\n        # or back to the destination node if the candidate is the last unvisited node.\n        \n        remaining_nodes_after_candidate = unvisited_nodes - {candidate_node}\n        \n        max_dist_from_candidate_to_future = 0.0 # Initialize with 0 for finding max distances\n\n        if not remaining_nodes_after_candidate:\n            # If candidate_node is the only unvisited node left, the \"max distance to future\"\n            # should be its distance to the destination.\n            max_dist_from_candidate_to_future = distance_matrix[candidate_node][destination_node]\n        else:\n            # Otherwise, find the maximum distance from candidate_node to any other remaining unvisited node.\n            for future_node in remaining_nodes_after_candidate:\n                max_dist_from_candidate_to_future = max(\n                    max_dist_from_candidate_to_future, \n                    distance_matrix[candidate_node][future_node]\n                )\n        \n        # Calculate the total heuristic cost for this candidate:\n        # current_node -> candidate_node (immediate cost) + max_distance_from_candidate_to_future\n        # This aims to select a node that is relatively close and doesn't leave a very remote node behind.\n        total_heuristic_cost = cost_to_candidate + max_dist_from_candidate_to_future\n        \n        # Update if this candidate offers a better heuristic score\n        if total_heuristic_cost < min_heuristic_cost:\n            min_heuristic_cost = total_heuristic_cost\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.58622,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm first creates a Restricted Candidate List (RCL) by selecting the 'k' unvisited nodes closest to the current position. From this RCL, it then chooses the node that minimizes the maximum distance to any other remaining unvisited node, effectively balancing immediate proximity with future tour connectivity.",
          "thought": "This algorithm extends the greedy approach by first identifying a restricted candidate list of the 'k' closest unvisited nodes and then selecting one from this list based on minimizing the maximum distance to any other remaining unvisited node, ensuring better overall connectivity.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node to visit using a Restricted Candidate List (RCL) heuristic\n    with a secondary 'min-max connectivity' criterion.\n    \n    Args:\n        current_node (int): The index of the node currently at.\n        destination_node (int): The index of the final node to return to (usually the starting node).\n        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.\n        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the \n                                         distance from node i to node j.\n    \n    Returns:\n        int: The index of the next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, the next step is to return to the destination node.\n        return destination_node\n\n    # Step 1: Identify candidates and their distances from the current_node\n    candidate_distances = []\n    for node in unvisited_nodes:\n        candidate_distances.append((distance_matrix[current_node][node], node))\n    \n    # Sort candidates by distance to current_node\n    candidate_distances.sort()\n\n    # Step 2: Form the Restricted Candidate List (RCL)\n    # Let's set k, the size of the RCL. It should be at least 1 and not exceed the number of unvisited nodes.\n    # Using min(3, len(unvisited_nodes)) ensures k is reasonable and valid for any number of unvisited nodes.\n    k = min(3, len(unvisited_nodes))\n    \n    restricted_candidate_list = [node_info[1] for node_info in candidate_distances[:k]]\n\n    # If RCL has only one candidate, simply return it.\n    if len(restricted_candidate_list) == 1:\n        return restricted_candidate_list[0]\n\n    # Step 3: Apply secondary criterion to select from RCL\n    # Select the node from RCL that minimizes the maximum distance from itself to any other remaining unvisited node.\n    min_max_dist_score = float('inf')\n    next_node = -1\n\n    for candidate_node in restricted_candidate_list:\n        max_dist_for_candidate = 0.0\n        \n        # Calculate the maximum distance from this candidate to any other truly unvisited node.\n        # This includes nodes not in RCL but still unvisited.\n        \n        # Create a temporary set of unvisited nodes excluding the current candidate for this calculation.\n        other_unvisited_nodes_for_calc = unvisited_nodes - {candidate_node}\n        \n        if not other_unvisited_nodes_for_calc:\n            # If after removing candidate_node, no other unvisited nodes remain,\n            # this candidate would be the last non-destination node to visit.\n            # Its max distance to 'other unvisited' is effectively 0.\n            max_dist_for_candidate = 0.0\n        else:\n            # Iterate through the remaining other unvisited nodes to find the maximum distance.\n            for other_node in other_unvisited_nodes_for_calc:\n                dist = distance_matrix[candidate_node][other_node]\n                if dist > max_dist_for_candidate:\n                    max_dist_for_candidate = dist\n        \n        # We want to minimize this maximum distance score.\n        # If multiple candidates have the same min_max_dist_score, the one encountered first (which is\n        # implicitly the one originally closer to current_node) will be chosen.\n        if max_dist_for_candidate < min_max_dist_score:\n            min_max_dist_score = max_dist_for_candidate\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 12.05941,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by primarily prioritizing those most centrally located among the *remaining* unvisited nodes, determined by minimizing their average distance to all others in that set. Ties are then broken by selecting the node that is closest to the current position.",
          "thought": "This algorithm prioritizes visiting unvisited nodes that are most centrally located among the remaining unvisited nodes, breaking ties by choosing the node closest to the current position.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node to visit based on a constructive heuristic that prioritizes\n    nodes central to the remaining unvisited nodes.\n    \n    Args:\n        current_node (int): The index of the node currently at.\n        destination_node (int): The index of the final node to return to (usually the starting node).\n        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.\n        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the \n                                         distance from node i to node j.\n    \n    Returns:\n        int: The index of the next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, the next step is to return to the destination node.\n        return destination_node\n\n    # If only one unvisited node left, it must be the next node\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    # Initialize with an infinitely high score to ensure any valid node will be preferred\n    # The heuristic score is a tuple: (average_distance_to_others, distance_from_current)\n    # This ensures primary sorting by average_distance_to_others, then by distance_from_current for ties.\n    min_heuristic_score_tuple = (float('inf'), float('inf')) \n    next_node = -1\n\n    for candidate_node in unvisited_nodes:\n        sum_other_unvisited_distances = 0\n        count_other_unvisited = 0\n        \n        # Calculate the sum of distances from the candidate_node to all other *remaining* unvisited nodes\n        for other_unvisited_node in unvisited_nodes:\n            if other_unvisited_node != candidate_node:\n                sum_other_unvisited_distances += distance_matrix[candidate_node][other_unvisited_node]\n                count_other_unvisited += 1\n        \n        # Calculate the average distance to other unvisited nodes\n        # If count_other_unvisited is 0, it means candidate_node is the only node in unvisited_nodes,\n        # which should be handled by the `len(unvisited_nodes) == 1` case. \n        # For safety, assign infinity if for some reason this condition is met.\n        if count_other_unvisited == 0:\n            avg_distance_to_others = float('inf')\n        else:\n            avg_distance_to_others = sum_other_unvisited_distances / count_other_unvisited\n        \n        # The secondary criterion: distance from the current_node to the candidate_node\n        distance_from_current = distance_matrix[current_node][candidate_node]\n        \n        # Form the heuristic score tuple\n        heuristic_score_tuple = (avg_distance_to_others, distance_from_current)\n        \n        # Compare tuples: Python's tuple comparison works element by element (lexicographical)\n        if heuristic_score_tuple < min_heuristic_score_tuple:\n            min_heuristic_score_tuple = heuristic_score_tuple\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 32.01287,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic builds a TSP tour by iteratively selecting the unvisited node farthest from the current position. The algorithm prioritizes maximizing the immediate travel distance to explore new regions, finally returning to the destination node after all others are visited.",
          "thought": "This algorithm constructs a TSP tour by iteratively selecting the farthest unvisited node from the current position, aiming to explore distant regions before connecting back.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node to visit based on a constructive heuristic (furthest neighbor).\n    \n    Args:\n        current_node (int): The index of the node currently at.\n        destination_node (int): The index of the final node to return to (usually the starting node).\n        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.\n        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the \n                                         distance from node i to node j.\n    \n    Returns:\n        int: The index of the next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, the next step is to return to the destination node.\n        return destination_node\n\n    max_distance = -float('inf')  # Initialize with negative infinity to find the maximum distance\n    next_node = -1\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance > max_distance:  # Select the node with the maximum distance\n            max_distance = distance\n            next_node = node\n            \n    return next_node",
          "objective": 36.64594,
          "other_inf": null
     }
]