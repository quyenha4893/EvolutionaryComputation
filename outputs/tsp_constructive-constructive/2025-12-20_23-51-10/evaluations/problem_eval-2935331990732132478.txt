def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    """
    Selects the next node to visit based on a constructive heuristic that minimizes
    the sum of the immediate travel cost and the maximum distance to any remaining future node.
    
    Args:
        current_node (int): The index of the node currently at.
        destination_node (int): The index of the final node to return to (usually the starting node).
        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.
        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the 
                                         distance from node i to node j.
    
    Returns:
        int: The index of the next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, the next step is to return to the destination node.
        return destination_node

    # If only one unvisited node left, it must be the next node
    if len(unvisited_nodes) == 1:
        return list(unvisited_nodes)[0]

    min_heuristic_cost = float('inf')
    next_node = -1

    for candidate_node in unvisited_nodes:
        # Step 1: Cost to reach the candidate node from the current position
        cost_to_candidate = distance_matrix[current_node][candidate_node]
        
        # Step 2: Maximum cost to move from the candidate node to any other *remaining* unvisited node,
        # or back to the destination node if the candidate is the last unvisited node.
        
        remaining_nodes_after_candidate = unvisited_nodes - {candidate_node}
        
        max_dist_from_candidate_to_future = 0.0 # Initialize with 0 for finding max distances

        if not remaining_nodes_after_candidate:
            # If candidate_node is the only unvisited node left, the "max distance to future"
            # should be its distance to the destination.
            max_dist_from_candidate_to_future = distance_matrix[candidate_node][destination_node]
        else:
            # Otherwise, find the maximum distance from candidate_node to any other remaining unvisited node.
            for future_node in remaining_nodes_after_candidate:
                max_dist_from_candidate_to_future = max(
                    max_dist_from_candidate_to_future, 
                    distance_matrix[candidate_node][future_node]
                )
        
        # Calculate the total heuristic cost for this candidate:
        # current_node -> candidate_node (immediate cost) + max_distance_from_candidate_to_future
        # This aims to select a node that is relatively close and doesn't leave a very remote node behind.
        total_heuristic_cost = cost_to_candidate + max_dist_from_candidate_to_future
        
        # Update if this candidate offers a better heuristic score
        if total_heuristic_cost < min_heuristic_cost:
            min_heuristic_cost = total_heuristic_cost
            next_node = candidate_node
            
    return next_node
