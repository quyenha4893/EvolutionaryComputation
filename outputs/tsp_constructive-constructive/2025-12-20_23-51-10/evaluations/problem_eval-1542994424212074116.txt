def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    """
    Selects the next node to visit based on a constructive heuristic that considers
    the immediate step and the best possible next step from that candidate.
    
    Args:
        current_node (int): The index of the node currently at.
        destination_node (int): The index of the final node to return to (usually the starting node).
        unvisited_nodes (set): A set of indices of nodes that have not yet been visited.
        distance_matrix (list of lists): A 2D list where distance_matrix[i][j] is the 
                                         distance from node i to node j.
    
    Returns:
        int: The index of the next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, the next step is to return to the destination node.
        return destination_node

    min_total_path_extension_cost = float('inf')
    next_node = -1

    for candidate_node in unvisited_nodes:
        # Step 1: Cost to reach the candidate node from the current position
        cost_to_candidate = distance_matrix[current_node][candidate_node]
        
        # Step 2: Minimum cost to move from the candidate node to any other *remaining* unvisited node,
        # or back to the destination node if the candidate is the last unvisited node.
        
        remaining_nodes_after_candidate = unvisited_nodes - {candidate_node}
        
        min_cost_from_candidate_to_future = float('inf')

        if not remaining_nodes_after_candidate:
            # If candidate_node is the only unvisited node left, the next step after it is the destination.
            min_cost_from_candidate_to_future = distance_matrix[candidate_node][destination_node]
        else:
            # Otherwise, find the minimum distance from candidate_node to any other remaining unvisited node.
            for future_node in remaining_nodes_after_candidate:
                min_cost_from_candidate_to_future = min(
                    min_cost_from_candidate_to_future, 
                    distance_matrix[candidate_node][future_node]
                )
        
        # Calculate the total path extension cost for this candidate:
        # current_node -> candidate_node -> best_future_node (or destination)
        total_path_extension_cost = cost_to_candidate + min_cost_from_candidate_to_future
        
        # Update if this candidate offers a better two-step path extension cost
        if total_path_extension_cost < min_total_path_extension_cost:
            min_total_path_extension_cost = total_path_extension_cost
            next_node = candidate_node
            
    return next_node
