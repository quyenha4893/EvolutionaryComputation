[
     {
          "algorithm": "This greedy heuristic constructs a TSP tour by iteratively selecting the unvisited node with the minimum distance from the current position. The path extends in this nearest-neighbor fashion until all other nodes have been visited, at which point the algorithm completes the cycle by returning to the designated starting node.",
          "thought": "The algorithm constructs the tour by iteratively selecting the unvisited node closest to the current node, completing the cycle by returning to the starting node when all other nodes have been visited.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on the greedy (nearest neighbor) heuristic.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_distance = math.inf\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by prioritizing the closest unvisited neighbor. It refines this choice by adding a very small weighted look-ahead, which considers the shortest possible next step from the candidate node to either another unvisited node or the tour's destination. Thus, immediate proximity dominates the decision, but a subtle bias is introduced to favor paths that also promise a slightly cheaper subsequent connection.",
          "thought": "This algorithm refines the Nearest Neighbor approach by primarily selecting the closest unvisited node, but it introduces a very subtle bias through a minimal weighted look-ahead, preferring candidates that also lead to a slightly cheaper subsequent step or final return to the destination.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a very subtle weighted look-ahead for the next step.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A very small weighting factor for the look-ahead distance.\n    # This makes the algorithm primarily act as Nearest Neighbor, but\n    # uses the look-ahead as a subtle tie-breaker or minor bias to avoid locally optimal\n    # choices that lead to significantly higher costs in the next step.\n    K = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_future_dist = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination_node\n            min_future_dist = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_future_dist:\n                    min_future_dist = future_distance\n        \n        # Combine immediate cost with the very slightly weighted future look-ahead distance.\n        # This allows the algorithm to prioritize immediate closeness while still considering\n        # the 'quality' of the subsequent step.\n        combined_cost = immediate_cost + K * min_future_dist\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01092,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by minimizing a combined cost function, which strongly prioritizes immediate travel distance (90% weight) over the candidate node's distance to the tour's destination (10% weight). This refined weighting, achieved by reducing the destination proximity weight `W` to 0.1, emphasizes local path optimization for enhanced travel efficiency.",
          "thought": "This algorithm refines the cost function of Algorithm 2 by multiplying its weight `W` for destination proximity by Algorithm 1's `bias_factor` of 0.5, creating a new `W` that further prioritizes immediate travel distance for enhanced path optimization while retaining crucial foresight.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a weighted combination of immediate distance\n    and the distance from the candidate node back to the destination node, with\n    an even stronger emphasis on immediate distance.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Original W from Algorithm 2 was 0.2.\n    # Algorithm 1's bias_factor was 0.5.\n    # New W is derived by multiplying these, further reducing the weight of destination proximity.\n    W_algorithm2_original = 0.2\n    bias_factor_algorithm1 = 0.5\n    W = W_algorithm2_original * bias_factor_algorithm1 # W = 0.2 * 0.5 = 0.1\n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate distance with the weighted distance from candidate back to destination.\n        # This formula balances making a locally optimal move with considering the eventual return cost.\n        combined_cost = (1 - W) * immediate_distance + W * distance_to_destination_from_candidate\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.20675,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by primarily minimizing the immediate travel distance from the current node to a candidate unvisited node. This immediate cost is then augmented by two weighted foresight components: a look-ahead to the closest *other* unvisited node (with weight W1=0.2) and the distance from the candidate node back to the tour's starting point (with weight W2=0.1), selecting the candidate with the lowest total combined cost.",
          "thought": "This algorithm selects the next node by minimizing a cost that primarily considers the immediate travel distance, but also incorporates a weighted look-ahead to the closest *other* unvisited node and a separate weighted consideration of the distance from the candidate node back to the starting point, balancing local greediness with foresight for tour completion and return.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a combined heuristic that considers\n    immediate distance, a look-ahead to the next unvisited node, and the distance\n    from the candidate node back to the destination.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the look-ahead to another unvisited node (similar to K in Algo 1)\n    W1 = 0.2\n    # Weighting factor for the distance to destination from candidate (similar to W in Algo 2)\n    W2 = 0.1\n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (core Nearest Neighbor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Look-ahead to the closest *other* unvisited node from the candidate\n        min_dist_to_other_unvisited = 0.0 # Default if no other unvisited nodes remain\n        remaining_after_candidate = unvisited_nodes - {candidate_node}\n        \n        if remaining_after_candidate:\n            min_dist_to_other_unvisited = math.inf\n            for other_future_node in remaining_after_candidate:\n                min_dist_to_other_unvisited = min(min_dist_to_other_unvisited, distance_matrix[candidate_node][other_future_node])\n        \n        # 3. Distance from the candidate node back to the destination node\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine all components\n        combined_cost = immediate_distance + (W1 * min_dist_to_other_unvisited) + (W2 * distance_to_destination_from_candidate)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.24339,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by minimizing a combined cost function. It heavily prioritizes the immediate travel distance from the current node while also giving a smaller weight to the candidate node's distance back to the tour's starting point. This balances local shortest path choices with a modest foresight for overall tour completion.",
          "thought": "This algorithm selects the next node by minimizing a combined cost that prioritizes immediate travel distance while also penalizing choices that significantly increase the eventual cost of returning to the starting node, thereby balancing short-term gain with long-term tour completion efficiency.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a weighted combination of immediate distance\n    and the distance from the candidate node back to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the distance to destination (0 <= W < 1)\n    # W=0 results in pure Nearest Neighbor (Algorithm 2).\n    # A small W value helps to keep the tour from straying too far from the destination,\n    # potentially reducing the cost of the final leg.\n    W = 0.2 \n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate distance with the weighted distance from candidate back to destination.\n        # This formula balances making a locally optimal move with considering the eventual return cost.\n        combined_cost = (1 - W) * immediate_distance + W * distance_to_destination_from_candidate\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm extends the nearest-neighbor approach by selecting the next unvisited node based on a combined score. This score weights the direct distance from the current node more heavily than its proximity to the designated starting node (with a `bias_factor` of 0.5), aiming for an overall shorter path that efficiently returns to the origin.",
          "thought": "This algorithm modifies the nearest-neighbor approach by selecting the next node based on a combined score of its direct distance from the current node and its proximity to the designated starting node, aiming to create a more globally informed path.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a nearest-neighbor approach biased by\n    proximity to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_biased_distance = math.inf\n    bias_factor = 0.5  # Controls the weight of the destination proximity\n\n    for node in unvisited_nodes:\n        # Calculate direct distance from current to candidate node\n        direct_distance = distance_matrix[current_node][node]\n        # Calculate heuristic distance from candidate node to the destination node\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Combine distances with a bias factor\n        # The goal is to prefer nodes that are not only close now but also lead to a\n        # path that potentially finishes closer to the start.\n        biased_distance = direct_distance + (distance_to_destination * bias_factor)\n\n        if biased_distance < min_biased_distance:\n            min_biased_distance = biased_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic enhances the Nearest Neighbor approach by selecting the next node based on a \"combined cost.\" For each potential next node, this cost is calculated as the immediate distance from the current node plus a weighted look-ahead. The look-ahead component represents the minimum distance from that potential node to any *other* remaining unvisited node, with a factor `K` determining its priority in the selection.",
          "thought": "This algorithm enhances the nearest neighbor approach by introducing a look-ahead mechanism, where the selection of the next node is based not only on its immediate proximity to the current node but also on the minimum distance from that potential next node to any other remaining unvisited node, effectively minimizing a weighted sum of the first two steps of the path.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a look-ahead for the next step.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the look-ahead distance (0 <= K <= 1)\n    # K=0 reverts to pure Nearest Neighbor. K=1 weighs both steps equally.\n    K = 0.5 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_future_dist = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination_node\n            min_future_dist = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_future_dist:\n                    min_future_dist = future_distance\n        \n        # New equation: Combine immediate cost with the weighted future look-ahead distance\n        # This gives preference to paths that are not only immediately close but also lead to good future options.\n        combined_cost = immediate_cost + K * min_future_dist\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.45538,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by minimizing a combined cost, which is the product of the immediate distance from the current node to a candidate and the candidate's distance back to the tour's starting point. This heuristic prioritizes nodes that are both nearby and favorably positioned for the final return to the origin.",
          "thought": "This algorithm selects the next unvisited node by minimizing the product of the immediate travel distance from the current node and the candidate node's distance back to the tour's starting point, favoring nodes that simultaneously offer short immediate travel and a good position for returning.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on minimizing the product of the immediate distance\n    and the distance from the candidate node back to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate distance and the distance from candidate back to destination using multiplication.\n        # This approach favors nodes that are both close immediately and are also positioned well for the return trip.\n        combined_cost = immediate_distance * distance_to_destination_from_candidate\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by minimizing a combined cost, where the immediate travel distance to a candidate node is most heavily weighted. It then considers a moderately weighted minimum distance from that candidate to any other unvisited node, and a less significant weighted cost for returning directly to the destination. This strategy prioritizes immediate progress while loosely factoring in future connectivity and eventual path closure.",
          "thought": "This heuristic selects the next node by evaluating a combined cost that includes the immediate travel distance, a weighted minimum distance to the next unvisited node, and an additional weighted cost for directly returning to the destination from the candidate node, aiming for a more holistic path evaluation.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    W1 = 0.4 \n    W2 = 0.2\n\n    for candidate_node in unvisited_nodes:\n        d_curr_cand = distance_matrix[current_node][candidate_node]\n\n        d_cand_next_min = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            d_cand_next_min = distance_matrix[candidate_node][destination_node]\n        else:\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < d_cand_next_min:\n                    d_cand_next_min = future_distance\n        \n        d_cand_dest = distance_matrix[candidate_node][destination_node]\n\n        combined_cost = d_curr_cand + W1 * d_cand_next_min + W2 * d_cand_dest\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.59781,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a weighted sum of three factors: immediate travel distance, a dynamically increasing emphasis on destination proximity, and a fixed consideration of the candidate's average distance to other unvisited nodes. This balances short-term efficiency with long-term tour coherence and closure as the tour progresses.",
          "thought": "This algorithm modifies the provided approach by introducing a dynamic weighting 'W' for destination proximity that increases as the tour progresses, alongside a new \"future connectivity\" component 'X' which considers the candidate node's average distance to other remaining unvisited nodes, balancing immediate gain with long-term tour coherence.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    {This algorithm modifies the provided approach by introducing a dynamic weighting 'W' for destination proximity that increases as the tour progresses, alongside a new \"future connectivity\" component 'X' which considers the candidate node's average distance to other remaining unvisited nodes, balancing immediate gain with long-term tour coherence.}\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    total_nodes = len(distance_matrix)\n    num_unvisited = len(unvisited_nodes)\n\n    # Calculate a dynamic weight (P2, or W) for the distance to destination component.\n    # Its influence increases as more nodes are visited, prioritizing closure towards the end.\n    W_min = 0.1 # Minimum weight for destination proximity, similar to original algorithm's W\n    W_max = 0.4 # Maximum weight for destination proximity\n    \n    # Progress ratio reflects how much of the unique nodes have been visited.\n    # It ranges from (1/total_nodes) for the first node choice to 1 when all nodes are visited.\n    if total_nodes == 0: # Handle edge case, though TSP implies at least 2 nodes\n        progress_ratio = 0.0\n    else:\n        progress_ratio = (total_nodes - num_unvisited) / total_nodes\n    \n    dynamic_W = W_min + (W_max - W_min) * progress_ratio\n\n    # Introduce a new fixed weight (P3, or X) for the 'future connectivity' component.\n    # This component considers the candidate node's average distance to other still unvisited nodes.\n    X = 0.1 # Weight for the average distance to other unvisited nodes\n\n    # Calculate the remaining weight (P1) for the immediate distance component.\n    # Ensure that dynamic_W + X does not exceed 1 to keep P1 positive.\n    # Max dynamic_W (0.4) + X (0.1) = 0.5, so P1 will always be at least 0.5.\n    P1 = 1.0 - dynamic_W - X\n    P2 = dynamic_W\n    P3 = X\n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Calculate the \"future connectivity\" cost: average distance from candidate to other unvisited nodes.\n        average_distance_to_other_unvisited_nodes = 0.0\n        other_unvisited_for_candidate = [u for u in unvisited_nodes if u != candidate_node]\n        \n        if other_unvisited_for_candidate:\n            sum_distances_to_others = sum(distance_matrix[candidate_node][u] for u in other_unvisited_for_candidate)\n            average_distance_to_other_unvisited_nodes = sum_distances_to_others / len(other_unvisited_for_candidate)\n        # If no other unvisited nodes (i.e., candidate is the last unique node), this term remains 0,\n        # effectively giving P3 * 0 to this component.\n\n        # Combine all three components with their respective dynamic/fixed weights.\n        combined_cost = (P1 * immediate_distance +\n                         P2 * distance_to_destination_from_candidate +\n                         P3 * average_distance_to_other_unvisited_nodes)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.63572,
          "other_inf": null
     }
]