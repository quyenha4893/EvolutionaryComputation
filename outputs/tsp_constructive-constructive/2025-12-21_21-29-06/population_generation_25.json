[
     {
          "algorithm": "This greedy heuristic constructs a TSP tour by iteratively selecting the unvisited node with the minimum distance from the current position. The path extends in this nearest-neighbor fashion until all other nodes have been visited, at which point the algorithm completes the cycle by returning to the designated starting node.",
          "thought": "The algorithm constructs the tour by iteratively selecting the unvisited node closest to the current node, completing the cycle by returning to the starting node when all other nodes have been visited.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on the greedy (nearest neighbor) heuristic.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_distance = math.inf\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by minimizing a combined cost function. It heavily prioritizes the immediate travel distance from the current node while also giving a smaller weight to the candidate node's distance back to the tour's starting point. This balances local shortest path choices with a modest foresight for overall tour completion.",
          "thought": "This algorithm selects the next node by minimizing a combined cost that prioritizes immediate travel distance while also penalizing choices that significantly increase the eventual cost of returning to the starting node, thereby balancing short-term gain with long-term tour completion efficiency.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a weighted combination of immediate distance\n    and the distance from the candidate node back to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the distance to destination (0 <= W < 1)\n    # W=0 results in pure Nearest Neighbor (Algorithm 2).\n    # A small W value helps to keep the tour from straying too far from the destination,\n    # potentially reducing the cost of the final leg.\n    W = 0.2 \n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate distance with the weighted distance from candidate back to destination.\n        # This formula balances making a locally optimal move with considering the eventual return cost.\n        combined_cost = (1 - W) * immediate_distance + W * distance_to_destination_from_candidate\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm extends the nearest-neighbor approach by selecting the next unvisited node based on a combined score. This score weights the direct distance from the current node more heavily than its proximity to the designated starting node (with a `bias_factor` of 0.5), aiming for an overall shorter path that efficiently returns to the origin.",
          "thought": "This algorithm modifies the nearest-neighbor approach by selecting the next node based on a combined score of its direct distance from the current node and its proximity to the designated starting node, aiming to create a more globally informed path.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a nearest-neighbor approach biased by\n    proximity to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_biased_distance = math.inf\n    bias_factor = 0.5  # Controls the weight of the destination proximity\n\n    for node in unvisited_nodes:\n        # Calculate direct distance from current to candidate node\n        direct_distance = distance_matrix[current_node][node]\n        # Calculate heuristic distance from candidate node to the destination node\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Combine distances with a bias factor\n        # The goal is to prefer nodes that are not only close now but also lead to a\n        # path that potentially finishes closer to the start.\n        biased_distance = direct_distance + (distance_to_destination * bias_factor)\n\n        if biased_distance < min_biased_distance:\n            min_biased_distance = biased_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic enhances the Nearest Neighbor approach by selecting the next node based on a \"combined cost.\" For each potential next node, this cost is calculated as the immediate distance from the current node plus a weighted look-ahead. The look-ahead component represents the minimum distance from that potential node to any *other* remaining unvisited node, with a factor `K` determining its priority in the selection.",
          "thought": "This algorithm enhances the nearest neighbor approach by introducing a look-ahead mechanism, where the selection of the next node is based not only on its immediate proximity to the current node but also on the minimum distance from that potential next node to any other remaining unvisited node, effectively minimizing a weighted sum of the first two steps of the path.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a look-ahead for the next step.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the look-ahead distance (0 <= K <= 1)\n    # K=0 reverts to pure Nearest Neighbor. K=1 weighs both steps equally.\n    K = 0.5 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_future_dist = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination_node\n            min_future_dist = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_future_dist:\n                    min_future_dist = future_distance\n        \n        # New equation: Combine immediate cost with the weighted future look-ahead distance\n        # This gives preference to paths that are not only immediately close but also lead to good future options.\n        combined_cost = immediate_cost + K * min_future_dist\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.45538,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by minimizing a combined cost, where the immediate travel distance to a candidate node is most heavily weighted. It then considers a moderately weighted minimum distance from that candidate to any other unvisited node, and a less significant weighted cost for returning directly to the destination. This strategy prioritizes immediate progress while loosely factoring in future connectivity and eventual path closure.",
          "thought": "This heuristic selects the next node by evaluating a combined cost that includes the immediate travel distance, a weighted minimum distance to the next unvisited node, and an additional weighted cost for directly returning to the destination from the candidate node, aiming for a more holistic path evaluation.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    W1 = 0.4 \n    W2 = 0.2\n\n    for candidate_node in unvisited_nodes:\n        d_curr_cand = distance_matrix[current_node][candidate_node]\n\n        d_cand_next_min = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            d_cand_next_min = distance_matrix[candidate_node][destination_node]\n        else:\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < d_cand_next_min:\n                    d_cand_next_min = future_distance\n        \n        d_cand_dest = distance_matrix[candidate_node][destination_node]\n\n        combined_cost = d_curr_cand + W1 * d_cand_next_min + W2 * d_cand_dest\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.59781,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next unvisited node by evaluating a weighted sum of its direct distance from the current node and its distance to the tour's starting node. Crucially, the weight (bias factor) for the starting node's proximity dynamically increases as more nodes are visited. This strategy effectively transitions from an initial nearest-neighbor approach to one that progressively prioritizes efficient closure of the tour by favoring nodes closer to the starting point.",
          "thought": "The new algorithm will extend the path by selecting the next unvisited node based on a weighted sum of its direct distance from the current node and its distance to the starting node, where the weight (bias factor) for the starting node's proximity dynamically increases as more nodes are visited, gradually transitioning from a pure nearest-neighbor strategy in the initial stages to one that strongly prioritizes closing the loop efficiently towards the end of the tour.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using an adaptively biased nearest-neighbor approach.\n    The bias towards the destination node increases as more nodes are visited,\n    transitioning from a more greedy approach initially to prioritizing closing the loop later.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    num_total_nodes = len(distance_matrix)\n    \n    # initial_nodes_to_visit_count represents the total number of nodes that need to be visited\n    # after starting, before returning to the destination.\n    # We assume num_total_nodes >= 2 for a meaningful TSP.\n    initial_nodes_to_visit_count = num_total_nodes - 1 \n\n    # Calculate the number of nodes already visited in the current path, excluding the starting node.\n    nodes_remaining_to_visit = len(unvisited_nodes)\n    nodes_visited_so_far_count = initial_nodes_to_visit_count - nodes_remaining_to_visit\n    \n    # The bias factor increases from 0 (pure nearest neighbor) to a value approaching 1\n    # as the tour progresses. This encourages a strong consideration for the destination\n    # node's proximity towards the end of the tour.\n    bias_factor = nodes_visited_so_far_count / initial_nodes_to_visit_count\n    \n    next_node = -1\n    min_biased_distance = math.inf\n\n    for node in unvisited_nodes:\n        direct_distance = distance_matrix[current_node][node]\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Combine distances with the dynamically adjusted bias factor\n        biased_distance = direct_distance + (distance_to_destination * bias_factor)\n\n        if biased_distance < min_biased_distance:\n            min_biased_distance = biased_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.64406,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a combined cost, which weighs the immediate distance with a dynamically adjusted look-ahead cost. The look-ahead cost, whose influence (K) increases with tour progress, is calculated by summing the minimum distance to any subsequent unvisited node and a weighted distance to the final destination. This strategy balances short-term proximity with long-term tour completion considerations.",
          "thought": "This algorithm dynamically adjusts the look-ahead's influence based on the proportion of visited nodes and enhances the look-ahead cost calculation by considering both the minimum distance to the next unvisited node and a weighted contribution of the distance from the potential next node to the final destination, aiming to balance immediate gain with the overall tour completion cost.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Hyperparameters for dynamic K and look-ahead penalty\n    K_min = 0.3  # Minimum weighting factor for look-ahead\n    K_max = 0.7  # Maximum weighting factor for look-ahead\n    Beta = 0.2   # Weight for the distance to destination in the look-ahead cost\n\n    # Calculate dynamic K based on tour progress\n    total_graph_nodes = len(distance_matrix)\n    num_unvisited_remaining = len(unvisited_nodes)\n    \n    # Progress ratio: 0 when tour just started, approaches 1 when almost finished\n    # (assuming destination_node is not in unvisited_nodes initially, which it shouldn't be for path construction)\n    # The current_node is also not in unvisited_nodes.\n    # So, total_graph_nodes - num_unvisited_remaining - 1 gives nodes visited (excluding start and end)\n    progress_ratio = (total_graph_nodes - num_unvisited_remaining - 1) / (total_graph_nodes - 2) if (total_graph_nodes - 2) > 0 else 0\n    \n    # Ensure progress_ratio is within [0, 1] bounds, especially for very small graphs\n    progress_ratio = max(0.0, min(1.0, progress_ratio))\n    \n    # K increases as the tour progresses, prioritizing look-ahead more towards the end\n    K = K_min + (K_max - K_min) * progress_ratio\n\n    for candidate_node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        effective_look_ahead_cost = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination\n            effective_look_ahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            min_dist_to_next_unvisited = math.inf\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_dist_to_next_unvisited:\n                    min_dist_to_next_unvisited = future_distance\n            \n            # Incorporate the distance from candidate_node to the destination into the look-ahead\n            dist_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n            \n            # New look-ahead calculation: nearest unvisited + weighted distance to destination\n            effective_look_ahead_cost = min_dist_to_next_unvisited + Beta * dist_to_destination_from_candidate\n        \n        # Combine immediate cost with the dynamically weighted effective look-ahead cost\n        combined_cost = immediate_cost + K * effective_look_ahead_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.70331,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm primarily selects the nearest unvisited node, while adaptively biasing the choice towards the `destination_node` with increasing weight as the tour progresses. A lower-weighted future connectivity cost is also considered, prioritizing nodes that maintain efficient average distances to other remaining unvisited locations.",
          "thought": "This algorithm enhances node selection by introducing an adaptive bias towards the destination based on tour progress and incorporating a future connectivity cost to prioritize nodes that maintain efficient links to the remaining unvisited locations.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a nearest-neighbor approach with an\n    adaptive destination bias and a connectivity cost.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_score = math.inf\n\n    num_total_cities = len(distance_matrix)\n    \n    # Calculate tour progress for an adaptive destination bias.\n    # This makes the influence of returning to the destination stronger as the tour progresses.\n    if num_total_cities <= 1: \n        tour_progress = 0.0 # No progress to calculate for 0 or 1 city.\n    else:\n        # num_nodes_to_visit_in_tour_segment is total cities minus the initial start node.\n        num_nodes_to_visit_in_tour_segment = num_total_cities - 1 \n        # num_nodes_visited_after_start counts nodes added to the path, excluding the start node itself.\n        num_nodes_visited_after_start = num_total_cities - len(unvisited_nodes) - 1\n        tour_progress = num_nodes_visited_after_start / num_nodes_to_visit_in_tour_segment\n\n    # Adaptive bias factor: ranges from 0.25 (at start of tour) to 0.75 (near end of tour).\n    adaptive_bias_factor = 0.25 + (0.5 * tour_progress)\n    \n    # Weight for the connectivity cost term. This can be tuned.\n    connectivity_weight = 0.2 \n\n    for node in unvisited_nodes:\n        # 1. Direct distance from current to candidate node\n        direct_distance = distance_matrix[current_node][node]\n\n        # 2. Distance from candidate node to the destination node, scaled by adaptive bias\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # 3. Connectivity cost: average distance from candidate to all other remaining unvisited nodes.\n        # This term encourages picking nodes that are 'central' to the remaining unvisited set,\n        # helping to maintain efficient future connections.\n        remaining_unvisited_excluding_candidate = unvisited_nodes - {node}\n        if not remaining_unvisited_excluding_candidate:\n            connectivity_cost = 0.0 # No other unvisited nodes left to connect to.\n        else:\n            connectivity_cost = sum(distance_matrix[node][k] for k in remaining_unvisited_excluding_candidate) / len(remaining_unvisited_excluding_candidate)\n\n        # Combine all factors into a single score. Lower score is preferred.\n        combined_score = direct_distance + \\\n                         (distance_to_destination * adaptive_bias_factor) + \\\n                         (connectivity_cost * connectivity_weight)\n\n        if combined_score < min_combined_score:\n            min_combined_score = combined_score\n            next_node = node\n\n    return next_node",
          "objective": 7.761,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by evaluating a combined cost that includes the immediate travel distance, a primary look-ahead to the candidate's closest subsequent unvisited node, and a secondary look-ahead considering the average distance from the candidate to all other remaining unvisited nodes. The secondary look-ahead's weight adaptively decreases as the number of unvisited nodes shrinks, thus prioritizing overall connectivity earlier in the tour.",
          "thought": "This heuristic extends the combined cost approach by evaluating candidate nodes based on their immediate distance, a primary weighted look-ahead to the closest subsequent node, and a secondary weighted look-ahead that considers the average distance to all other remaining unvisited nodes from the candidate, with the secondary weight adapting dynamically based on the number of unvisited nodes to emphasize overall connectivity earlier in the tour.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance, a primary minimum look-ahead, and a secondary\n    average look-ahead, with adaptive weighting.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weights for the combined cost equation\n    ALPHA = 0.6 # Weight for the primary (closest) look-ahead component\n    BETA_BASE = 0.3 # Base weight for the secondary (average spread) look-ahead component\n\n    # Total initial number of nodes, inferred from the distance matrix size\n    total_nodes_count = len(distance_matrix)\n    \n    # Adaptive BETA: decreases as fewer nodes remain, reducing the importance of average spread towards the end.\n    # This factor ranges from BETA_BASE (when all nodes are unvisited) down to 0 (when no nodes are unvisited).\n    BETA_ADAPTED = BETA_BASE * (len(unvisited_nodes) / total_nodes_count) if total_nodes_count > 0 else 0\n\n    for candidate_node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Tier 1 Look-ahead: The minimum distance from candidate_node to its next *single* stop.\n        # This closely mimics the original algorithm's min_future_dist.\n        tier1_look_ahead_cost = math.inf\n        \n        # Tier 2 Look-ahead: The average distance from candidate_node to all *other* remaining unvisited nodes.\n        # This captures the \"spread\" or \"density\" of the remaining problem.\n        total_dist_to_others = 0\n        num_others = 0\n\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last node to visit, the next step is directly to the destination.\n            tier1_look_ahead_cost = distance_matrix[candidate_node][destination_node]\n            tier2_look_ahead_cost = 0 # No other nodes for an \"average spread\" calculation\n            effective_beta_term = 0 # No BETA contribution as there's no spread\n        else:\n            # Calculate min_dist and sum_dist to all other remaining nodes\n            for future_node in remaining_unvisited_after_candidate:\n                dist_from_cand_to_future = distance_matrix[candidate_node][future_node]\n                \n                if dist_from_cand_to_future < tier1_look_ahead_cost:\n                    tier1_look_ahead_cost = dist_from_cand_to_future\n                \n                total_dist_to_others += dist_from_cand_to_future\n                num_others += 1\n            \n            # Calculate the average distance for the Tier 2 look-ahead\n            tier2_look_ahead_cost = total_dist_to_others / num_others\n            effective_beta_term = BETA_ADAPTED * tier2_look_ahead_cost\n\n        # The new combined cost equation:\n        # immediate_cost + (ALPHA * min_dist_to_next) + (ADAPTIVE_BETA * average_dist_to_all_others)\n        combined_cost = immediate_cost + \\\n                        (ALPHA * tier1_look_ahead_cost) + \\\n                        effective_beta_term\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.78818,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a total cost that primarily considers the immediate travel distance to a candidate node. This immediate cost is augmented by a weighted look-ahead component, which itself sums the candidate's closest connection to any other unvisited node and its direct distance to the final destination. The bias factor (0.5) thus ensures the immediate travel distance contributes more heavily to the decision than the combined future path estimates.",
          "thought": "This algorithm extends the No.2's biased nearest-neighbor approach by modifying its look-ahead component to sum the minimum distance from the candidate node to any subsequent unvisited node (inspired by No.1) and the candidate's distance to the destination, all weighted by a bias factor.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a nearest-neighbor approach biased by\n    a combined look-ahead that considers both the next closest unvisited node\n    and the proximity to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n    bias_factor = 0.5  # Weighting factor for the combined look-ahead components\n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node (inspired by No.1)\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_dist_to_next_unvisited = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, this part becomes the direct path to destination\n            min_dist_to_next_unvisited = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_dist_to_next_unvisited:\n                    min_dist_to_next_unvisited = future_distance\n        \n        # Step 3: Calculate the distance from candidate_node to the destination_node (inspired by No.2)\n        distance_to_destination = distance_matrix[candidate_node][destination_node]\n\n        # Step 4: Combine these two look-ahead components into a single future cost estimate\n        combined_future_component = min_dist_to_next_unvisited + distance_to_destination\n        \n        # Step 5: Calculate the total combined cost, following No.2's structure\n        # immediate_cost + (combined_future_component * bias_factor)\n        combined_cost = immediate_cost + (combined_future_component * bias_factor)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.87125,
          "other_inf": null
     }
]