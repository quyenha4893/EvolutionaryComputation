{
     "algorithm": "This heuristic selects the next node by minimizing a weighted composite score for each candidate. This score combines the immediate travel distance with the average of all potential future edge lengths, calculated among remaining unvisited nodes and back to the destination. The `alpha` parameter explicitly controls the priority given to the immediate step versus the expected average cost of the remaining tour segments.",
     "thought": "This heuristic selects the next node by minimizing a weighted composite score that combines the immediate travel distance to a candidate node with the average of all possible future edge lengths among remaining unvisited nodes and to the destination, aiming to balance immediate cost with the overall expected smoothness of the remaining tour.",
     "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a Weighted Average Remaining Gap (WARG) heuristic.\n    This heuristic selects the next node by minimizing a weighted composite score that combines\n    the immediate travel distance to a candidate node with the average of all possible edge lengths\n    that would exist among the remaining unvisited nodes or between any remaining unvisited\n    node and the destination, aiming to balance immediate cost with the expected average\n    future travel burden.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_total_score = math.inf\n    \n    # Weighting factor for immediate cost vs average future gap.\n    # A value of 0.5 gives equal weight. Higher values prioritize immediate cost.\n    alpha = 0.5 \n\n    for candidate_node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][candidate_node]\n        \n        # Simulate visiting this candidate node by removing it from the unvisited set\n        temp_unvisited = unvisited_nodes - {candidate_node}\n        \n        average_remaining_gap = 0.0\n        num_potential_gaps = 0\n\n        if not temp_unvisited:\n            # If no other nodes are left after selecting candidate_node,\n            # the only 'gap' is the final return from candidate_node to the destination.\n            average_remaining_gap = distance_matrix[candidate_node][destination_node]\n            num_potential_gaps = 1\n        else:\n            # Calculate the sum and count of all potential edge lengths in the *reduced* problem:\n            # 1. Between any two nodes remaining in temp_unvisited.\n            # 2. Between any node in temp_unvisited and the destination_node.\n            \n            sum_of_gaps = 0.0\n            \n            temp_unvisited_list = list(temp_unvisited) # Convert set to list for indexed iteration\n\n            # Add distances between remaining unvisited nodes\n            for i in range(len(temp_unvisited_list)):\n                u = temp_unvisited_list[i]\n                for j in range(i + 1, len(temp_unvisited_list)):\n                    v = temp_unvisited_list[j]\n                    sum_of_gaps += distance_matrix[u][v]\n                    num_potential_gaps += 1\n                \n                # Add distances from remaining unvisited nodes back to the destination\n                sum_of_gaps += distance_matrix[u][destination_node]\n                num_potential_gaps += 1\n            \n            if num_potential_gaps > 0:\n                average_remaining_gap = sum_of_gaps / num_potential_gaps\n            else:\n                # Should not happen if temp_unvisited is not empty as handled above.\n                # But as a safeguard, if no gaps can be formed, default to 0.\n                average_remaining_gap = 0.0\n        \n        # The total score is a weighted combination of immediate cost\n        # and the average potential gap in the remaining subproblem.\n        total_score = alpha * immediate_cost + (1 - alpha) * average_remaining_gap\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = candidate_node\n\n    return next_node",
     "objective": 6.81065,
     "other_inf": null
}