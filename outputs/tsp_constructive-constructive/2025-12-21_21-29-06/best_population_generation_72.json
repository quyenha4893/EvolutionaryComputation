{
     "algorithm": "This heuristic selects the next node by strongly prioritizing the immediate distance to a candidate node. It combines this with a weakly-weighted, two-step look-ahead that estimates the remaining path cost from the candidate, through its closest unvisited neighbor, and directly back to the destination. This approach balances immediate greedy choices with a subtle consideration of both future connectivity and the tour's eventual return to its start.",
     "thought": "This algorithm refines the weighted look-ahead of Algorithm 2 by estimating the remaining path cost from a candidate node as the sum of the distance to its closest unvisited neighbor and the distance from that neighbor directly back to the tour's starting point, thereby integrating a more explicit \"return-to-destination\" perspective similar to Algorithm 1 into the look-ahead.",
     "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a weighted two-step look-ahead.\n    The look-ahead estimates the remaining path from the candidate node through its\n    closest unvisited neighbor and then directly back to the destination.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A very small weighting factor for the look-ahead distance, similar to Algorithm 2.\n    K = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate an estimated remaining path cost from candidate_node.\n        # This is a two-step look-ahead: candidate -> closest_next_unvisited -> destination.\n        estimated_remaining_path_cost = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node,\n            # the remaining path is just from candidate_node to destination_node.\n            estimated_remaining_path_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes.\n            min_dist_from_candidate_to_next_unvisited = math.inf\n            closest_next_unvisited = -1\n\n            for future_node in remaining_unvisited_after_candidate:\n                dist = distance_matrix[candidate_node][future_node]\n                if dist < min_dist_from_candidate_to_next_unvisited:\n                    min_dist_from_candidate_to_next_unvisited = dist\n                    closest_next_unvisited = future_node\n            \n            # Estimate the remaining path cost as:\n            # (distance from candidate to its closest unvisited neighbor)\n            # + (distance from that closest unvisited neighbor directly to the destination_node)\n            # This integrates Algorithm 1's idea of considering the path back to the destination.\n            # 'closest_next_unvisited' is guaranteed to be found because 'remaining_unvisited_after_candidate' is not empty.\n            estimated_remaining_path_cost = min_dist_from_candidate_to_next_unvisited + distance_matrix[closest_next_unvisited][destination_node]\n\n        # Combine immediate cost with the weighted estimated remaining path cost.\n        combined_cost = immediate_cost + K * estimated_remaining_path_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
     "objective": 7.00166,
     "other_inf": null
}