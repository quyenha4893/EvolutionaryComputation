{
     "algorithm": "This heuristic selects the next node by minimizing a composite score that balances immediate cost with future tour viability. The composite score adds the direct travel distance to a candidate node to the maximum possible edge length remaining among unvisited nodes or to the destination. This strategy prevents the formation of excessively large isolated sections in the future tour by proactively considering potential bottlenecks.",
     "thought": "This heuristic selects the next node by minimizing a composite score that combines the immediate travel distance to a candidate node with the maximum possible edge length that would exist among the remaining unvisited nodes or between any remaining unvisited node and the destination, aiming to prevent the creation of excessively large isolated sections in the future tour.",
     "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a Minimizing Maximum Remaining Gap (MMRG) heuristic.\n    This heuristic selects the next node by minimizing a composite score that combines\n    the immediate travel distance to a candidate node with the maximum possible edge length\n    that would exist among the remaining unvisited nodes or between any remaining unvisited\n    node and the destination, aiming to prevent the creation of excessively large isolated\n    sections in the future tour.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_total_score = math.inf\n\n    for candidate_node in unvisited_nodes:\n        immediate_cost = distance_matrix[current_node][candidate_node]\n        \n        # Simulate visiting this candidate node by removing it from the unvisited set\n        temp_unvisited = unvisited_nodes - {candidate_node}\n        \n        max_remaining_gap = 0.0 # Distances are non-negative, so 0.0 is a safe initial max\n\n        if not temp_unvisited:\n            # If no other nodes are left after selecting candidate_node,\n            # the only 'gap' is the final return from candidate_node to the destination.\n            max_remaining_gap = distance_matrix[candidate_node][destination_node]\n        else:\n            # Calculate the maximum distance among all possible connections in the *reduced* problem:\n            # 1. Between any two nodes remaining in temp_unvisited.\n            # 2. Between any node in temp_unvisited and the destination_node.\n            # This represents the largest 'gap' we would be left with in the future.\n            \n            # Convert set to list for easier iteration and to avoid re-hashing\n            temp_unvisited_list = list(temp_unvisited)\n\n            for i in range(len(temp_unvisited_list)):\n                u = temp_unvisited_list[i]\n                # Check distances between remaining unvisited nodes\n                for j in range(i + 1, len(temp_unvisited_list)):\n                    v = temp_unvisited_list[j]\n                    max_remaining_gap = max(max_remaining_gap, distance_matrix[u][v])\n                \n                # Check distances from remaining unvisited nodes back to the destination\n                max_remaining_gap = max(max_remaining_gap, distance_matrix[u][destination_node])\n        \n        # The total score combines the immediate cost to reach the candidate node\n        # and the maximum potential gap (bottleneck) in the remaining subproblem.\n        total_score = immediate_cost + max_remaining_gap\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = candidate_node\n\n    return next_node",
     "objective": 6.82024,
     "other_inf": null
}