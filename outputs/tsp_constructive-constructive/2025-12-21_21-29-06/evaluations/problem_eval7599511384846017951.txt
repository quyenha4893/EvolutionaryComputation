import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    Selects the next node to visit by minimizing a two-step lookahead cost.
    This heuristic calculates the immediate distance to a candidate node and
    then adds the shortest possible subsequent distance from that candidate node
    to any other remaining unvisited node or back to the destination. The goal
    is to find the candidate node that offers the most efficient two-step path.

    Args:
        current_node: The node currently at.
        destination_node: The starting node of the tour, to which the path must return.
        unvisited_nodes: A set of nodes that have not yet been visited.
        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]
                         is the distance between node i and node j.

    Returns:
        The next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_two_step_cost = math.inf

    for candidate_node in unvisited_nodes:
        # Calculate the immediate cost to travel from current_node to candidate_node
        immediate_cost = distance_matrix[current_node][candidate_node]
        
        # Calculate the minimum cost for the *next* step from the candidate_node.
        # This looks for the shortest path from candidate_node to any other
        # remaining unvisited node or directly to the destination.
        
        min_subsequent_cost = math.inf 
        
        # Create a temporary set of remaining unvisited nodes for the lookahead
        remaining_nodes_for_lookahead = unvisited_nodes - {candidate_node}
        
        if not remaining_nodes_for_lookahead:
            # If the candidate_node is the last unvisited node, the only subsequent step
            # is to return to the destination.
            min_subsequent_cost = distance_matrix[candidate_node][destination_node]
        else:
            # Consider all other unvisited nodes as potential next steps
            for next_possible_target in remaining_nodes_for_lookahead:
                min_subsequent_cost = min(
                    min_subsequent_cost,
                    distance_matrix[candidate_node][next_possible_target]
                )
            
            # Always consider returning to the destination as a possible next step from candidate_node,
            # even if other unvisited nodes remain.
            min_subsequent_cost = min(
                min_subsequent_cost,
                distance_matrix[candidate_node][destination_node]
            )
        
        # The total score is the sum of the immediate cost and the estimated minimum subsequent cost.
        total_two_step_cost = immediate_cost + min_subsequent_cost

        if total_two_step_cost < min_two_step_cost:
            min_two_step_cost = total_two_step_cost
            next_node = candidate_node

    return next_node
