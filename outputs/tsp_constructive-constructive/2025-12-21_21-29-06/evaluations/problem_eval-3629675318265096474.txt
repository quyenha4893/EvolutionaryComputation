import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    Selects the next node to visit using a Weighted Average Remaining Gap (WARG) heuristic.
    This heuristic selects the next node by minimizing a weighted composite score that combines
    the immediate travel distance to a candidate node with the average of all possible edge lengths
    that would exist among the remaining unvisited nodes or between any remaining unvisited
    node and the destination, aiming to balance immediate cost with the expected average
    future travel burden.

    Args:
        current_node: The node currently at.
        destination_node: The starting node of the tour, to which the path must return.
        unvisited_nodes: A set of nodes that have not yet been visited.
        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]
                         is the distance between node i and node j.

    Returns:
        The next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_total_score = math.inf
    
    # Weighting factor for immediate cost vs average future gap.
    # A value of 0.5 gives equal weight. Higher values prioritize immediate cost.
    alpha = 0.5 

    for candidate_node in unvisited_nodes:
        immediate_cost = distance_matrix[current_node][candidate_node]
        
        # Simulate visiting this candidate node by removing it from the unvisited set
        temp_unvisited = unvisited_nodes - {candidate_node}
        
        average_remaining_gap = 0.0
        num_potential_gaps = 0

        if not temp_unvisited:
            # If no other nodes are left after selecting candidate_node,
            # the only 'gap' is the final return from candidate_node to the destination.
            average_remaining_gap = distance_matrix[candidate_node][destination_node]
            num_potential_gaps = 1
        else:
            # Calculate the sum and count of all potential edge lengths in the *reduced* problem:
            # 1. Between any two nodes remaining in temp_unvisited.
            # 2. Between any node in temp_unvisited and the destination_node.
            
            sum_of_gaps = 0.0
            
            temp_unvisited_list = list(temp_unvisited) # Convert set to list for indexed iteration

            # Add distances between remaining unvisited nodes
            for i in range(len(temp_unvisited_list)):
                u = temp_unvisited_list[i]
                for j in range(i + 1, len(temp_unvisited_list)):
                    v = temp_unvisited_list[j]
                    sum_of_gaps += distance_matrix[u][v]
                    num_potential_gaps += 1
                
                # Add distances from remaining unvisited nodes back to the destination
                sum_of_gaps += distance_matrix[u][destination_node]
                num_potential_gaps += 1
            
            if num_potential_gaps > 0:
                average_remaining_gap = sum_of_gaps / num_potential_gaps
            else:
                # Should not happen if temp_unvisited is not empty as handled above.
                # But as a safeguard, if no gaps can be formed, default to 0.
                average_remaining_gap = 0.0
        
        # The total score is a weighted combination of immediate cost
        # and the average potential gap in the remaining subproblem.
        total_score = alpha * immediate_cost + (1 - alpha) * average_remaining_gap

        if total_score < min_total_score:
            min_total_score = total_score
            next_node = candidate_node

    return next_node
