importance as the tour nears completion.
3.  **Isolation penalty**: Discouraging choices that would leave other unvisited nodes far from the destination, thus preventing "stranding" of remaining nodes.

{The algorithm selects the next unvisited node by primarily minimizing immediate travel distance, multiplicatively penalized by a dynamically weighted factor based on the candidate node's distance back to the starting point, and additionally incurring an additive penalty for choices that isolate remaining unvisited nodes far from the destination.}
```python
import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_combined_cost = math.inf

    total_nodes = len(distance_matrix)
    
    # Calculate tour progress: as more nodes are visited, this factor increases from ~0 to 1.
    # It represents the proportion of nodes already included in the tour.
    nodes_in_tour_so_far = total_nodes - len(unvisited_nodes)
    progress_factor = (nodes_in_tour_so_far / (total_nodes - 1)) if total_nodes > 1 else 1.0

    # Dynamic weighting for the multiplicative foresight penalty.
    # It starts at a base value and increases as the tour progresses,
    # making the incentive to head towards the destination stronger at the end.
    BASE_MULT_W_FORESIGHT = 0.002
    MAX_ADD_MULT_W_FORESIGHT = 0.008
    W_foresight_multiplier = BASE_MULT_W_FORESIGHT + (MAX_ADD_MULT_W_FORESIGHT * progress_factor)

    # A weighting factor for the additive isolation penalty.
    # This penalty discourages choices that leave remaining unvisited nodes very far from the destination.
    W_isolation_penalty = 0.005 

    for candidate_node in unvisited_nodes:
        # 1. Immediate cost from current_node to candidate_node (primary factor)
        immediate_distance = distance_matrix[current_node][candidate_node]

        # 2. Distance from the candidate node back to the destination node (foresight factor)
        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]

        # 3. Combine the immediate distance with a multiplicative penalty based on dynamic foresight.
        #    The factor (1 + W * dist_to_dest) ensures that the penalty increases with
        #    distance_to_destination_from_candidate, effectively "magnifying" the immediate cost.
        foresight_penalized_immediate_cost = immediate_distance * (1 + W_foresight_multiplier * distance_to_destination_from_candidate)

        # 4. Isolation penalty: Considers the maximum distance from any *other* remaining unvisited node
        #    back to the destination node, after `candidate_node` is selected.
        other_unvisited_after_candidate = unvisited_nodes - {candidate_node}
        
        isolation_penalty_cost = 0.0
        if other_unvisited_after_candidate:
            max_dist_others_to_destination = 0.0
            for other_node in other_unvisited_after_candidate:
                max_dist_others_to_destination = max(max_dist_others_to_destination, distance_matrix[other_node][destination_node])
            
            isolation_penalty_cost = W_isolation_penalty * max_dist_others_to_destination

        # 5. Combine all components: the multiplicatively penalized immediate cost, plus the additive isolation penalty.
        combined_cost = foresight_penalized_immediate_cost + isolation_penalty_cost

        if combined_cost < min_combined_cost:
            min_combined_cost = combined_cost
            next_node = candidate_node

    return next_node
