import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    Selects the next node to visit using a nearest-neighbor approach with an
    adaptive destination bias and a connectivity cost.

    Args:
        current_node: The node currently at.
        destination_node: The starting node of the tour, to which the path must return.
        unvisited_nodes: A set of nodes that have not yet been visited.
        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]
                         is the distance between node i and node j.

    Returns:
        The next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_combined_score = math.inf

    num_total_cities = len(distance_matrix)
    
    # Calculate tour progress for an adaptive destination bias.
    # This makes the influence of returning to the destination stronger as the tour progresses.
    if num_total_cities <= 1: 
        tour_progress = 0.0 # No progress to calculate for 0 or 1 city.
    else:
        # num_nodes_to_visit_in_tour_segment is total cities minus the initial start node.
        num_nodes_to_visit_in_tour_segment = num_total_cities - 1 
        # num_nodes_visited_after_start counts nodes added to the path, excluding the start node itself.
        num_nodes_visited_after_start = num_total_cities - len(unvisited_nodes) - 1
        tour_progress = num_nodes_visited_after_start / num_nodes_to_visit_in_tour_segment

    # Adaptive bias factor: ranges from 0.25 (at start of tour) to 0.75 (near end of tour).
    adaptive_bias_factor = 0.25 + (0.5 * tour_progress)
    
    # Weight for the connectivity cost term. This can be tuned.
    connectivity_weight = 0.2 

    for node in unvisited_nodes:
        # 1. Direct distance from current to candidate node
        direct_distance = distance_matrix[current_node][node]

        # 2. Distance from candidate node to the destination node, scaled by adaptive bias
        distance_to_destination = distance_matrix[node][destination_node]

        # 3. Connectivity cost: average distance from candidate to all other remaining unvisited nodes.
        # This term encourages picking nodes that are 'central' to the remaining unvisited set,
        # helping to maintain efficient future connections.
        remaining_unvisited_excluding_candidate = unvisited_nodes - {node}
        if not remaining_unvisited_excluding_candidate:
            connectivity_cost = 0.0 # No other unvisited nodes left to connect to.
        else:
            connectivity_cost = sum(distance_matrix[node][k] for k in remaining_unvisited_excluding_candidate) / len(remaining_unvisited_excluding_candidate)

        # Combine all factors into a single score. Lower score is preferred.
        combined_score = direct_distance + \
                         (distance_to_destination * adaptive_bias_factor) + \
                         (connectivity_cost * connectivity_weight)

        if combined_score < min_combined_score:
            min_combined_score = combined_score
            next_node = node

    return next_node
