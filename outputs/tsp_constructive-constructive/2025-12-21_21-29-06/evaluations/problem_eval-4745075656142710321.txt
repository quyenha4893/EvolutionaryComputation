importance of the return path as more nodes are visited.}

```python
import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    Selects the next node to visit based on a dynamically weighted combination of immediate distance
    and the distance from the candidate node back to the destination node.
    The weight (W) increases as more nodes are visited, prioritizing pure nearest neighbor early
    and the return path later.

    Args:
        current_node: The node currently at.
        destination_node: The starting node of the tour, to which the path must return.
        unvisited_nodes: A set of nodes that have not yet been visited.
        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]
                         is the distance between node i and node j.

    Returns:
        The next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_combined_cost = math.inf

    N_total_nodes = len(distance_matrix)
    
    # Calculate the number of edges already added to the path so far.
    # The path starts implicitly with 1 node (the destination_node), and we're looking for the next node.
    # So, (N_total_nodes - len(unvisited_nodes)) gives the count of nodes currently in the path.
    # Subtract 1 to get the number of edges already formed.
    num_edges_made_so_far = N_total_nodes - len(unvisited_nodes) - 1

    # Dynamically adjust the weighting factor W.
    # W starts at 0 (pure Nearest Neighbor) when no edges have been made (initial step).
    # W increases to 1 when N_total_nodes - 2 edges have been made (last step before returning to destination).
    if N_total_nodes <= 2:
        # For very small graphs, dynamic weighting isn't meaningful; default to pure NN (W=0)
        W = 0.0
    else:
        W = num_edges_made_so_far / (N_total_nodes - 2)

    for candidate_node in unvisited_nodes:
        immediate_distance = distance_matrix[current_node][candidate_node]
        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]

        # Combine immediate distance with the weighted distance from candidate back to destination.
        combined_cost = (1 - W) * immediate_distance + W * distance_to_destination_from_candidate

        if combined_cost < min_combined_cost:
            min_combined_cost = combined_cost
            next_node = candidate_node

    return next_node
