import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    Selects the next node to visit using an Adaptive Weighted Two-Step Minimum Cost heuristic.
    This heuristic adaptively weights the immediate travel cost and the estimated minimum future cost
    based on the proportion of nodes already visited, prioritizing immediate gains early in the tour
    and emphasizing future connectivity as the tour nears completion.

    Args:
        current_node: The node currently at.
        destination_node: The starting node of the tour, to which the path must return.
        unvisited_nodes: A set of nodes that have not yet been visited.
        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]
                         is the distance between node i and node j.

    Returns:
        The next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    num_all_nodes = len(distance_matrix)
    num_remaining_unvisited = len(unvisited_nodes)

    # Calculate an adaptive weighting factor 'w' for the future cost component.
    # 'w' increases as more nodes are visited, shifting priority from immediate cost
    # to future connectivity and the final return to the destination.
    # The 'num_all_nodes - 1' in the denominator accounts for the starting node already being implicitly "visited"
    # and not being in `unvisited_nodes` initially (unless destination is explicitly part of the visit list).
    # It ensures 'w' ranges from 0 (at the start of the tour) to nearly 1 (towards the end).
    if num_all_nodes <= 1: # Handle edge case for very small graphs, though unvisited_nodes check should catch it.
        return destination_node
    
    # w = (number of intermediate nodes visited so far) / (total number of intermediate nodes)
    # Total intermediate nodes = num_all_nodes - 1 (if destination is start) - 1 (if current_node is counted)
    # The number of "actual" nodes to visit in between start and end is `num_all_nodes - 1`.
    # And `num_remaining_unvisited` is how many of those are still left.
    # So, `(num_all_nodes - 1) - num_remaining_unvisited` is the count of intermediate nodes already chosen.
    w = ((num_all_nodes - 1) - num_remaining_unvisited) / (num_all_nodes - 1)

    next_node = -1
    min_total_score = math.inf

    for candidate_node in unvisited_nodes:
        # Calculate the immediate cost to travel from current_node to candidate_node
        immediate_cost = distance_matrix[current_node][candidate_node]
        
        # Calculate the minimum cost for the *next* step from the candidate_node.
        # This looks for the shortest path from candidate_node to any other
        # remaining unvisited node or directly to the destination.
        
        min_cost_from_candidate_to_next = math.inf
        
        # Create a temporary set of other unvisited nodes, excluding the current candidate
        other_unvisited_nodes_from_candidate = unvisited_nodes - {candidate_node}
        
        if other_unvisited_nodes_from_candidate:
            # Consider all other unvisited nodes as potential next steps from the candidate
            for next_possible_target in other_unvisited_nodes_from_candidate:
                min_cost_from_candidate_to_next = min(
                    min_cost_from_candidate_to_next,
                    distance_matrix[candidate_node][next_possible_target]
                )
        # If candidate_node is the last unvisited node, min_cost_from_candidate_to_next
        # will remain math.inf unless updated by the destination cost.

        # Always consider returning to the destination as a possible next step from candidate_node.
        # This handles the case where candidate_node is the last unvisited node,
        # or if returning to destination is the shortest path from candidate_node.
        min_cost_from_candidate_to_next = min(
            min_cost_from_candidate_to_next,
            distance_matrix[candidate_node][destination_node]
        )
        
        # The total score is the adaptively weighted sum of the immediate cost
        # and the estimated minimum cost for the next step.
        total_score = (1 - w) * immediate_cost + w * min_cost_from_candidate_to_next

        if total_score < min_total_score:
            min_total_score = total_score
            next_node = candidate_node

    return next_node
