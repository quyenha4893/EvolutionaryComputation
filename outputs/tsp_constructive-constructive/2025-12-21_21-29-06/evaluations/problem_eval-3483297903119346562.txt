import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    {This algorithm dynamically adjusts the foresight weight based on the proportion of nodes already visited in the tour, gradually increasing its influence as the tour approaches completion to better guide the path towards the destination node.}
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_combined_cost = math.inf

    # Calculate total number of nodes in the graph
    total_nodes_in_graph = len(distance_matrix)
    
    # Define the range for the dynamic foresight weight, for example, from a small base to a higher maximum.
    min_dynamic_weight = 0.05  # A small base weight for foresight
    max_dynamic_weight = 0.8   # Maximum influence of foresight as the tour nears its end
    
    # Calculate the number of nodes that have already been incorporated into the path.
    # This represents the "progress" of the tour.
    # (total_nodes_in_graph - 1) is the total number of nodes that must be visited before returning to destination.
    # len(unvisited_nodes) is how many nodes are still left to pick.
    # So, ((total_nodes_in_graph - 1) - len(unvisited_nodes)) gives the count of nodes already visited.
    num_nodes_visited_in_path = (total_nodes_in_graph - 1) - len(unvisited_nodes)
    
    # Calculate progress ratio (from 0.0 to 1.0)
    if (total_nodes_in_graph - 1) > 0:
        progress_ratio = num_nodes_visited_in_path / (total_nodes_in_graph - 1)
    else:
        # This case happens if total_nodes_in_graph is 1 (only destination node) or 0.
        # In a valid TSP, total_nodes_in_graph would be at least 2 for unvisited_nodes to not be empty.
        progress_ratio = 0.0
        
    # Ensure progress_ratio is within [0.0, 1.0] to handle any potential floating point quirks
    progress_ratio = max(0.0, min(1.0, progress_ratio))
        
    # Dynamically adjust the foresight weight based on the progress of the tour
    # It starts at min_dynamic_weight and increases linearly towards max_dynamic_weight
    # as more nodes are visited.
    W_return_foresight = min_dynamic_weight + (max_dynamic_weight - min_dynamic_weight) * progress_ratio

    for candidate_node in unvisited_nodes:
        # 1. Immediate cost from current_node to candidate_node (primary factor)
        immediate_distance = distance_matrix[current_node][candidate_node]

        # 2. Dynamically weighted distance from the candidate node back to the destination node
        # (secondary, dynamically-weighted foresight factor)
        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]

        # Combine the immediate distance with the dynamically adjusted foresight component
        combined_cost = immediate_distance + (W_return_foresight * distance_to_destination_from_candidate)

        if combined_cost < min_combined_cost:
            min_combined_cost = combined_cost
            next_node = candidate_node

    return next_node
