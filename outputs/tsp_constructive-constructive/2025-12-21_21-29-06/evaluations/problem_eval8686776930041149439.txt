import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    Selects the next node to visit using a Minimizing Maximum Remaining Gap (MMRG) heuristic.
    This heuristic selects the next node by minimizing a composite score that combines
    the immediate travel distance to a candidate node with the maximum possible edge length
    that would exist among the remaining unvisited nodes or between any remaining unvisited
    node and the destination, aiming to prevent the creation of excessively large isolated
    sections in the future tour.

    Args:
        current_node: The node currently at.
        destination_node: The starting node of the tour, to which the path must return.
        unvisited_nodes: A set of nodes that have not yet been visited.
        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]
                         is the distance between node i and node j.

    Returns:
        The next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_total_score = math.inf

    for candidate_node in unvisited_nodes:
        immediate_cost = distance_matrix[current_node][candidate_node]
        
        # Simulate visiting this candidate node by removing it from the unvisited set
        temp_unvisited = unvisited_nodes - {candidate_node}
        
        max_remaining_gap = 0.0 # Distances are non-negative, so 0.0 is a safe initial max

        if not temp_unvisited:
            # If no other nodes are left after selecting candidate_node,
            # the only 'gap' is the final return from candidate_node to the destination.
            max_remaining_gap = distance_matrix[candidate_node][destination_node]
        else:
            # Calculate the maximum distance among all possible connections in the *reduced* problem:
            # 1. Between any two nodes remaining in temp_unvisited.
            # 2. Between any node in temp_unvisited and the destination_node.
            # This represents the largest 'gap' we would be left with in the future.
            
            # Convert set to list for easier iteration and to avoid re-hashing
            temp_unvisited_list = list(temp_unvisited)

            for i in range(len(temp_unvisited_list)):
                u = temp_unvisited_list[i]
                # Check distances between remaining unvisited nodes
                for j in range(i + 1, len(temp_unvisited_list)):
                    v = temp_unvisited_list[j]
                    max_remaining_gap = max(max_remaining_gap, distance_matrix[u][v])
                
                # Check distances from remaining unvisited nodes back to the destination
                max_remaining_gap = max(max_remaining_gap, distance_matrix[u][destination_node])
        
        # The total score combines the immediate cost to reach the candidate node
        # and the maximum potential gap (bottleneck) in the remaining subproblem.
        total_score = immediate_cost + max_remaining_gap

        if total_score < min_total_score:
            min_total_score = total_score
            next_node = candidate_node

    return next_node
