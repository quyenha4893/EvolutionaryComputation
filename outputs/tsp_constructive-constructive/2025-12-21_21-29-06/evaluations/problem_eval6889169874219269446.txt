import math

def select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:
    """
    Selects the next unvisited node by minimizing the sum of the immediate travel distance
    to a candidate node and the shortest travel distance from that candidate node
    to any other remaining unvisited node (or to the destination if no other unvisited nodes remain).

    Args:
        current_node: The node currently at.
        destination_node: The starting node of the tour, to which the path must return.
        unvisited_nodes: A set of nodes that have not yet been visited.
        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]
                         is the distance between node i and node j.

    Returns:
        The next node to visit.
    """
    if not unvisited_nodes:
        # If all other nodes have been visited, return to the destination node (start node)
        return destination_node

    next_node = -1
    min_two_step_cost = math.inf

    for candidate_node in unvisited_nodes:
        # Step 1: Calculate the immediate distance from the current_node to the candidate_node
        cost_step1 = distance_matrix[current_node][candidate_node]

        # Step 2: Determine the shortest distance from the candidate_node to the next potential step.
        # This next step can be either another unvisited node or the final destination.
        
        # Create a temporary set of nodes that are truly 'remaining unvisited' for the second step,
        # which means excluding the current 'candidate_node' itself.
        remaining_unvisited_for_step2 = unvisited_nodes - {candidate_node}
        
        cost_step2 = math.inf

        if not remaining_unvisited_for_step2:
            # If the candidate_node was the last unvisited node, the tour must then go to the destination.
            cost_step2 = distance_matrix[candidate_node][destination_node]
        else:
            # Otherwise, find the shortest distance from the candidate_node to any of the
            # remaining unvisited nodes.
            for next_step_target in remaining_unvisited_for_step2:
                cost_step2 = min(cost_step2, distance_matrix[candidate_node][next_step_target])
        
        # The total score for this candidate is the sum of the immediate step and the
        # "best" next step from that candidate.
        total_candidate_score = cost_step1 + cost_step2

        if total_candidate_score < min_two_step_cost:
            min_two_step_cost = total_candidate_score
            next_node = candidate_node

    return next_node
