[
     {
          "algorithm": "This heuristic selects the next node by strongly prioritizing the immediate distance to a candidate node. It combines this with a weakly-weighted, two-step look-ahead that estimates the remaining path cost from the candidate, through its closest unvisited neighbor, and directly back to the destination. This approach balances immediate greedy choices with a subtle consideration of both future connectivity and the tour's eventual return to its start.",
          "thought": "This algorithm refines the weighted look-ahead of Algorithm 2 by estimating the remaining path cost from a candidate node as the sum of the distance to its closest unvisited neighbor and the distance from that neighbor directly back to the tour's starting point, thereby integrating a more explicit \"return-to-destination\" perspective similar to Algorithm 1 into the look-ahead.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a weighted two-step look-ahead.\n    The look-ahead estimates the remaining path from the candidate node through its\n    closest unvisited neighbor and then directly back to the destination.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A very small weighting factor for the look-ahead distance, similar to Algorithm 2.\n    K = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate an estimated remaining path cost from candidate_node.\n        # This is a two-step look-ahead: candidate -> closest_next_unvisited -> destination.\n        estimated_remaining_path_cost = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node,\n            # the remaining path is just from candidate_node to destination_node.\n            estimated_remaining_path_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes.\n            min_dist_from_candidate_to_next_unvisited = math.inf\n            closest_next_unvisited = -1\n\n            for future_node in remaining_unvisited_after_candidate:\n                dist = distance_matrix[candidate_node][future_node]\n                if dist < min_dist_from_candidate_to_next_unvisited:\n                    min_dist_from_candidate_to_next_unvisited = dist\n                    closest_next_unvisited = future_node\n            \n            # Estimate the remaining path cost as:\n            # (distance from candidate to its closest unvisited neighbor)\n            # + (distance from that closest unvisited neighbor directly to the destination_node)\n            # This integrates Algorithm 1's idea of considering the path back to the destination.\n            # 'closest_next_unvisited' is guaranteed to be found because 'remaining_unvisited_after_candidate' is not empty.\n            estimated_remaining_path_cost = min_dist_from_candidate_to_next_unvisited + distance_matrix[closest_next_unvisited][destination_node]\n\n        # Combine immediate cost with the weighted estimated remaining path cost.\n        combined_cost = immediate_cost + K * estimated_remaining_path_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.00166,
          "other_inf": null
     },
     {
          "algorithm": "This greedy heuristic constructs a TSP tour by iteratively selecting the unvisited node with the minimum distance from the current position. The path extends in this nearest-neighbor fashion until all other nodes have been visited, at which point the algorithm completes the cycle by returning to the designated starting node.",
          "thought": "The algorithm constructs the tour by iteratively selecting the unvisited node closest to the current node, completing the cycle by returning to the starting node when all other nodes have been visited.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on the greedy (nearest neighbor) heuristic.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_distance = math.inf\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by prioritizing the closest unvisited neighbor. It refines this choice by adding a very small weighted look-ahead, which considers the shortest possible next step from the candidate node to either another unvisited node or the tour's destination. Thus, immediate proximity dominates the decision, but a subtle bias is introduced to favor paths that also promise a slightly cheaper subsequent connection.",
          "thought": "This algorithm refines the Nearest Neighbor approach by primarily selecting the closest unvisited node, but it introduces a very subtle bias through a minimal weighted look-ahead, preferring candidates that also lead to a slightly cheaper subsequent step or final return to the destination.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a very subtle weighted look-ahead for the next step.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A very small weighting factor for the look-ahead distance.\n    # This makes the algorithm primarily act as Nearest Neighbor, but\n    # uses the look-ahead as a subtle tie-breaker or minor bias to avoid locally optimal\n    # choices that lead to significantly higher costs in the next step.\n    K = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_future_dist = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination_node\n            min_future_dist = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_future_dist:\n                    min_future_dist = future_distance\n        \n        # Combine immediate cost with the very slightly weighted future look-ahead distance.\n        # This allows the algorithm to prioritize immediate closeness while still considering\n        # the 'quality' of the subsequent step.\n        combined_cost = immediate_cost + K * min_future_dist\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01092,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm is a modified Nearest Neighbor heuristic that primarily selects the next node based on the shortest immediate distance, while subtly incorporating a weighted one-step look-ahead to the next unvisited node and an even more subtle weighted bias towards candidates closer to the final destination to facilitate easier tour closure.",
          "thought": "This algorithm extends the nearest neighbor approach by not only considering the immediate step and a one-step look-ahead from the candidate but also introduces a subtle, weighted bias towards candidates that maintain proximity to the tour's final destination, promoting paths that are easier to close.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance, a one-step look-ahead, and an additional\n    subtle bias for candidates that are also close to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the one-step look-ahead distance.\n    K_lookahead = 0.01 \n    # A very small weighting factor for the direct distance from candidate_node to destination_node.\n    # This introduces a subtle bias towards candidates that keep the tour path relatively close\n    # to the eventual return point, making the final leg potentially cheaper.\n    L_return_proximity_bias = 0.005 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node.\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_next_step_cost = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, its next step must be to the destination_node\n            min_next_step_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_next_step_cost:\n                    min_next_step_cost = future_distance\n        \n        # Step 3: Calculate the direct distance from the candidate node to the destination node.\n        # This term biases towards candidates that are 'well-positioned' for the final return.\n        return_to_destination_cost = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate cost with weighted look-ahead and weighted return-to-destination proximity bias.\n        # This new equation balances immediate gain, short-term future prospects, and long-term path closure.\n        combined_cost = immediate_cost + K_lookahead * min_next_step_cost + L_return_proximity_bias * return_to_destination_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01722,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by primarily minimizing the immediate travel distance, augmented by a very small, weighted foresight component considering the candidate node's distance back to the tour's starting point. This subtle weighting helps gently guide the tour towards closure while prioritizing local proximity.",
          "thought": "This algorithm extends the nearest-neighbor logic of Algorithm 2 by incorporating a very small weighted foresight component, inspired by Algorithm 1, which considers the distance from each candidate unvisited node back to the tour's starting point to gently guide the path towards closure.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit by primarily minimizing the immediate travel distance\n    (like the greedy approach of Algo 2), but with a small weighted consideration\n    for the distance from the candidate node back to the tour's starting point,\n    inspired by the foresight component of Algo 1.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A small weighting factor for the distance from candidate to destination,\n    # significantly lower than W2 in Algo 1, to provide a subtle guidance.\n    W_return_foresight = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (primary factor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Weighted distance from the candidate node back to the destination node\n        # (secondary, subtle foresight factor)\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine the immediate distance with the weighted foresight component\n        combined_cost = immediate_distance + (W_return_foresight * distance_to_destination_from_candidate)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01797,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next `candidate_node` by evaluating a combined cost for each, which includes the immediate travel distance, an average distance to its two closest unvisited neighbors for future foresight, and its distance to the final `destination_node`. It dynamically adjusts these look-ahead and destination return weights throughout the tour, prioritizing broader future options initially and increasingly emphasizing path closure as fewer nodes remain. The node with the minimum calculated combined cost is chosen.",
          "thought": "candidate_node",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    N_total = len(distance_matrix) # Total number of nodes in the graph\n    \n    # Base weights from the original algorithm\n    W1_base = 0.2\n    W2_base = 0.1\n\n    # Calculate dynamic weights based on tour progress\n    # max_unvisited_nodes represents the total number of nodes to be picked for the tour (N-1 for N nodes),\n    # assuming the starting node is already 'visited' implicitly.\n    max_unvisited_nodes = N_total - 1 \n\n    # If max_unvisited_nodes is 0 (i.e., N_total is 1), there's no path to construct.\n    # This scenario is already handled by 'if not unvisited_nodes:' above,\n    # as unvisited_nodes would be empty if N_total is 1 and current_node is the only node.\n    # We include it in calculations below with a check to prevent division by zero.\n    \n    num_nodes_currently_unvisited = len(unvisited_nodes)\n    \n    if max_unvisited_nodes > 0:\n        # W1_dynamic decreases as the tour progresses (fewer future options, less emphasis on broad look-ahead)\n        # It scales from W1_base (at the start of tour) down to a smaller value (when few nodes left).\n        W1_dynamic = W1_base * (num_nodes_currently_unvisited / max_unvisited_nodes)\n        \n        # W2_dynamic increases as the tour progresses (more emphasis on tour closure)\n        # It scales from a small value (at the start) up to W2_base (when only one node left).\n        # When num_nodes_currently_unvisited == 1, (1 - (1-1)/max_unvisited_nodes) = 1, so W2_dynamic = W2_base.\n        W2_dynamic = W2_base * (1 - (num_nodes_currently_unvisited - 1) / max_unvisited_nodes)\n    else: # max_unvisited_nodes is 0, implying N_total is 1, thus unvisited_nodes is empty.\n          # This block should ideally not be reached if 'if not unvisited_nodes' is at the top.\n          # Set weights to 0 as there's no more path to construct.\n        W1_dynamic = 0.0\n        W2_dynamic = 0.0\n\n    # Ensure non-negative weights (float arithmetic safety)\n    W1_dynamic = max(0.0, W1_dynamic)\n    W2_dynamic = max(0.0, W2_dynamic)\n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Broader look-ahead: average of the two closest *other* unvisited nodes from the candidate\n        min_avg_dist_to_other_unvisited = 0.0\n        remaining_after_candidate = unvisited_nodes - {candidate_node}\n        \n        if remaining_after_candidate:\n            distances_to_others = []\n            for other_future_node in remaining_after_candidate:\n                distances_to_others.append(distance_matrix[candidate_node][other_future_node])\n            \n            distances_to_others.sort()\n            \n            # Take the average of the top 2 closest distances for broader foresight\n            # If only one node remaining, just take that one distance.\n            if len(distances_to_others) >= 2:\n                min_avg_dist_to_other_unvisited = (distances_to_others[0] + distances_to_others[1]) / 2.0\n            else: # len == 1\n                min_avg_dist_to_other_unvisited = distances_to_others[0]\n        \n        # 3. Distance from the candidate node back to the destination node\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine all components with dynamically adjusted weights\n        combined_cost = immediate_distance + \\\n                        (W1_dynamic * min_avg_dist_to_other_unvisited) + \\\n                        (W2_dynamic * distance_to_destination_from_candidate)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.18326,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node by evaluating a combined cost that is a weighted average of the immediate travel cost and the shortest possible future step from that candidate node. The algorithm prioritizes the immediate travel distance (weighted by `1-K`, typically 0.8) over the short-term future connectivity (weighted by `K`, typically 0.2) to balance current and subsequent path quality. For each candidate, this look-ahead considers the minimum distance to any *remaining* unvisited node or, if none, directly to the final destination.",
          "thought": "This algorithm selects the next node by balancing the immediate travel cost with the shortest possible future step from that candidate node, using a weighted average with an increased look-ahead emphasis compared to the original subtle bias.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    if not unvisited_nodes:\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A weighting factor for the look-ahead distance, giving it more significance.\n    # This K value (e.g., 0.2) is chosen to provide a more balanced consideration\n    # between immediate proximity and future path quality, rather than a subtle bias.\n    K = 0.2 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node\n        min_future_dist = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination_node\n            min_future_dist = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_future_dist:\n                    min_future_dist = future_distance\n        \n        # Combine immediate cost with the weighted future look-ahead distance using a weighted average.\n        # This equation provides a more direct balance between immediate and future costs,\n        # where K explicitly controls the influence of the look-ahead in a proportional manner.\n        combined_cost = (1 - K) * immediate_cost + K * min_future_dist\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.20148,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by minimizing a combined cost function, which strongly prioritizes immediate travel distance (90% weight) over the candidate node's distance to the tour's destination (10% weight). This refined weighting, achieved by reducing the destination proximity weight `W` to 0.1, emphasizes local path optimization for enhanced travel efficiency.",
          "thought": "This algorithm refines the cost function of Algorithm 2 by multiplying its weight `W` for destination proximity by Algorithm 1's `bias_factor` of 0.5, creating a new `W` that further prioritizes immediate travel distance for enhanced path optimization while retaining crucial foresight.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a weighted combination of immediate distance\n    and the distance from the candidate node back to the destination node, with\n    an even stronger emphasis on immediate distance.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Original W from Algorithm 2 was 0.2.\n    # Algorithm 1's bias_factor was 0.5.\n    # New W is derived by multiplying these, further reducing the weight of destination proximity.\n    W_algorithm2_original = 0.2\n    bias_factor_algorithm1 = 0.5\n    W = W_algorithm2_original * bias_factor_algorithm1 # W = 0.2 * 0.5 = 0.1\n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate distance with the weighted distance from candidate back to destination.\n        # This formula balances making a locally optimal move with considering the eventual return cost.\n        combined_cost = (1 - W) * immediate_distance + W * distance_to_destination_from_candidate\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.20675,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by primarily minimizing the immediate travel distance from the current node to a candidate unvisited node. This immediate cost is then augmented by two weighted foresight components: a look-ahead to the closest *other* unvisited node (with weight W1=0.2) and the distance from the candidate node back to the tour's starting point (with weight W2=0.1), selecting the candidate with the lowest total combined cost.",
          "thought": "This algorithm selects the next node by minimizing a cost that primarily considers the immediate travel distance, but also incorporates a weighted look-ahead to the closest *other* unvisited node and a separate weighted consideration of the distance from the candidate node back to the starting point, balancing local greediness with foresight for tour completion and return.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a combined heuristic that considers\n    immediate distance, a look-ahead to the next unvisited node, and the distance\n    from the candidate node back to the destination.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the look-ahead to another unvisited node (similar to K in Algo 1)\n    W1 = 0.2\n    # Weighting factor for the distance to destination from candidate (similar to W in Algo 2)\n    W2 = 0.1\n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (core Nearest Neighbor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Look-ahead to the closest *other* unvisited node from the candidate\n        min_dist_to_other_unvisited = 0.0 # Default if no other unvisited nodes remain\n        remaining_after_candidate = unvisited_nodes - {candidate_node}\n        \n        if remaining_after_candidate:\n            min_dist_to_other_unvisited = math.inf\n            for other_future_node in remaining_after_candidate:\n                min_dist_to_other_unvisited = min(min_dist_to_other_unvisited, distance_matrix[candidate_node][other_future_node])\n        \n        # 3. Distance from the candidate node back to the destination node\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine all components\n        combined_cost = immediate_distance + (W1 * min_dist_to_other_unvisited) + (W2 * distance_to_destination_from_candidate)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.24339,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by minimizing a combined cost function. It heavily prioritizes the immediate travel distance from the current node while also giving a smaller weight to the candidate node's distance back to the tour's starting point. This balances local shortest path choices with a modest foresight for overall tour completion.",
          "thought": "This algorithm selects the next node by minimizing a combined cost that prioritizes immediate travel distance while also penalizing choices that significantly increase the eventual cost of returning to the starting node, thereby balancing short-term gain with long-term tour completion efficiency.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a weighted combination of immediate distance\n    and the distance from the candidate node back to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the distance to destination (0 <= W < 1)\n    # W=0 results in pure Nearest Neighbor (Algorithm 2).\n    # A small W value helps to keep the tour from straying too far from the destination,\n    # potentially reducing the cost of the final leg.\n    W = 0.2 \n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate distance with the weighted distance from candidate back to destination.\n        # This formula balances making a locally optimal move with considering the eventual return cost.\n        combined_cost = (1 - W) * immediate_distance + W * distance_to_destination_from_candidate\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     }
]