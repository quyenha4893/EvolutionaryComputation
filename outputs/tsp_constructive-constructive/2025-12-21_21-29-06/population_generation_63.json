[
     {
          "algorithm": "This heuristic selects the next node by strongly prioritizing the immediate distance to a candidate node. It combines this with a weakly-weighted, two-step look-ahead that estimates the remaining path cost from the candidate, through its closest unvisited neighbor, and directly back to the destination. This approach balances immediate greedy choices with a subtle consideration of both future connectivity and the tour's eventual return to its start.",
          "thought": "This algorithm refines the weighted look-ahead of Algorithm 2 by estimating the remaining path cost from a candidate node as the sum of the distance to its closest unvisited neighbor and the distance from that neighbor directly back to the tour's starting point, thereby integrating a more explicit \"return-to-destination\" perspective similar to Algorithm 1 into the look-ahead.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a weighted two-step look-ahead.\n    The look-ahead estimates the remaining path from the candidate node through its\n    closest unvisited neighbor and then directly back to the destination.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A very small weighting factor for the look-ahead distance, similar to Algorithm 2.\n    K = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate an estimated remaining path cost from candidate_node.\n        # This is a two-step look-ahead: candidate -> closest_next_unvisited -> destination.\n        estimated_remaining_path_cost = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node,\n            # the remaining path is just from candidate_node to destination_node.\n            estimated_remaining_path_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes.\n            min_dist_from_candidate_to_next_unvisited = math.inf\n            closest_next_unvisited = -1\n\n            for future_node in remaining_unvisited_after_candidate:\n                dist = distance_matrix[candidate_node][future_node]\n                if dist < min_dist_from_candidate_to_next_unvisited:\n                    min_dist_from_candidate_to_next_unvisited = dist\n                    closest_next_unvisited = future_node\n            \n            # Estimate the remaining path cost as:\n            # (distance from candidate to its closest unvisited neighbor)\n            # + (distance from that closest unvisited neighbor directly to the destination_node)\n            # This integrates Algorithm 1's idea of considering the path back to the destination.\n            # 'closest_next_unvisited' is guaranteed to be found because 'remaining_unvisited_after_candidate' is not empty.\n            estimated_remaining_path_cost = min_dist_from_candidate_to_next_unvisited + distance_matrix[closest_next_unvisited][destination_node]\n\n        # Combine immediate cost with the weighted estimated remaining path cost.\n        combined_cost = immediate_cost + K * estimated_remaining_path_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.00166,
          "other_inf": null
     },
     {
          "algorithm": "This greedy heuristic constructs a TSP tour by iteratively selecting the unvisited node with the minimum distance from the current position. The path extends in this nearest-neighbor fashion until all other nodes have been visited, at which point the algorithm completes the cycle by returning to the designated starting node.",
          "thought": "The algorithm constructs the tour by iteratively selecting the unvisited node closest to the current node, completing the cycle by returning to the starting node when all other nodes have been visited.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on the greedy (nearest neighbor) heuristic.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_distance = math.inf\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by primarily minimizing the immediate travel distance from the current location. This immediate cost is then multiplicatively increased by a weighted factor based on the candidate node's distance back to the tour's starting point, thereby magnifying the cost for options that stray further from closure.",
          "thought": "This algorithm selects the next unvisited node by primarily minimizing the immediate travel distance, which is multiplicatively penalized by a weighted factor based on the candidate node's distance back to the tour's starting point, thereby magnifying the cost for nodes that stray further from closure.",
          "code": "import math\n\n# {This algorithm selects the next unvisited node by primarily minimizing the immediate travel distance, which is multiplicatively penalized by a weighted factor based on the candidate node's distance back to the tour's starting point, thereby magnifying the cost for nodes that stray further from closure.}\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit by primarily minimizing the immediate travel distance,\n    multiplicatively penalized by a weighted factor based on the candidate node's\n    distance back to the tour's starting point.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A weighting factor for the multiplicative penalty of the return distance.\n    # This value determines how strongly the return distance's penalty is applied.\n    # A small positive value ensures the immediate distance remains the primary factor,\n    # while the foresight acts as a increasing penalty multiplier.\n    W_multiplicative_penalty = 0.005 \n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (primary factor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Distance from the candidate node back to the destination node (foresight factor)\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine the immediate distance with a multiplicative penalty based on foresight.\n        # The factor (1 + W * dist_to_dest) ensures that the penalty increases with\n        # distance_to_destination_from_candidate, effectively \"magnifying\" the immediate cost.\n        combined_cost = immediate_distance * (1 + W_multiplicative_penalty * distance_to_destination_from_candidate)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.00657,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by prioritizing the closest unvisited neighbor. It refines this choice by adding a very small weighted look-ahead, which considers the shortest possible next step from the candidate node to either another unvisited node or the tour's destination. Thus, immediate proximity dominates the decision, but a subtle bias is introduced to favor paths that also promise a slightly cheaper subsequent connection.",
          "thought": "This algorithm refines the Nearest Neighbor approach by primarily selecting the closest unvisited node, but it introduces a very subtle bias through a minimal weighted look-ahead, preferring candidates that also lead to a slightly cheaper subsequent step or final return to the destination.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a very subtle weighted look-ahead for the next step.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A very small weighting factor for the look-ahead distance.\n    # This makes the algorithm primarily act as Nearest Neighbor, but\n    # uses the look-ahead as a subtle tie-breaker or minor bias to avoid locally optimal\n    # choices that lead to significantly higher costs in the next step.\n    K = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_future_dist = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination_node\n            min_future_dist = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_future_dist:\n                    min_future_dist = future_distance\n        \n        # Combine immediate cost with the very slightly weighted future look-ahead distance.\n        # This allows the algorithm to prioritize immediate closeness while still considering\n        # the 'quality' of the subsequent step.\n        combined_cost = immediate_cost + K * min_future_dist\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01092,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm primarily prioritizes the immediate nearest neighbor by using a zero foresight weight for most of the tour. However, it dynamically activates a significant foresight component (with a weight of 0.5) when only two or fewer nodes remain unvisited. This strategic shift guides the tour towards an efficient closure by considering the path back to the starting node.",
          "thought": "This algorithm primarily uses a pure nearest-neighbor selection strategy (inspired by Algo 2) for most of the tour, but significantly increases the weighting of the foresight component (distance back to the starting node from Algo 1) when only a few nodes remain unvisited, to strategically guide the tour towards an efficient closure.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node by primarily using a nearest-neighbor strategy for most of the tour,\n    and then significantly increasing the weight of the foresight component (distance back to\n    the destination node) when only a few nodes remain unvisited, to guide towards efficient closure.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Dynamically adjust the foresight weight based on the number of unvisited nodes.\n    # For most of the tour (more than 2 unvisited nodes), use a zero foresight weight,\n    # effectively acting like the pure greedy approach (Algo 2).\n    # When only a few nodes remain, significantly increase the foresight weight\n    # to prioritize efficient return to the destination (inspired by Algo 1, but with stronger emphasis).\n    \n    if len(unvisited_nodes) > 2:\n        # Behave like the pure nearest-neighbor (Algo 2) for most of the tour,\n        # as Algo 2 outperformed Algo 1's small fixed foresight.\n        W_return_foresight = 0.0 \n    else:\n        # When nearing the end (e.g., 2 or 1 unvisited nodes left),\n        # make the return distance more impactful to guide towards a better closure.\n        # The value 0.5 is a chosen constant to give noticeable influence.\n        W_return_foresight = 0.5 \n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (primary factor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Weighted distance from the candidate node back to the destination node\n        # (secondary, dynamically weighted foresight factor)\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine the immediate distance with the dynamically weighted foresight component\n        combined_cost = immediate_distance + (W_return_foresight * distance_to_destination_from_candidate)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01238,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm is a modified Nearest Neighbor heuristic that primarily selects the next node based on the shortest immediate distance, while subtly incorporating a weighted one-step look-ahead to the next unvisited node and an even more subtle weighted bias towards candidates closer to the final destination to facilitate easier tour closure.",
          "thought": "This algorithm extends the nearest neighbor approach by not only considering the immediate step and a one-step look-ahead from the candidate but also introduces a subtle, weighted bias towards candidates that maintain proximity to the tour's final destination, promoting paths that are easier to close.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance, a one-step look-ahead, and an additional\n    subtle bias for candidates that are also close to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the one-step look-ahead distance.\n    K_lookahead = 0.01 \n    # A very small weighting factor for the direct distance from candidate_node to destination_node.\n    # This introduces a subtle bias towards candidates that keep the tour path relatively close\n    # to the eventual return point, making the final leg potentially cheaper.\n    L_return_proximity_bias = 0.005 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node.\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_next_step_cost = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, its next step must be to the destination_node\n            min_next_step_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_next_step_cost:\n                    min_next_step_cost = future_distance\n        \n        # Step 3: Calculate the direct distance from the candidate node to the destination node.\n        # This term biases towards candidates that are 'well-positioned' for the final return.\n        return_to_destination_cost = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate cost with weighted look-ahead and weighted return-to-destination proximity bias.\n        # This new equation balances immediate gain, short-term future prospects, and long-term path closure.\n        combined_cost = immediate_cost + K_lookahead * min_next_step_cost + L_return_proximity_bias * return_to_destination_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01722,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next unvisited node by primarily minimizing the immediate travel distance, augmented by a very small, weighted foresight component considering the candidate node's distance back to the tour's starting point. This subtle weighting helps gently guide the tour towards closure while prioritizing local proximity.",
          "thought": "This algorithm extends the nearest-neighbor logic of Algorithm 2 by incorporating a very small weighted foresight component, inspired by Algorithm 1, which considers the distance from each candidate unvisited node back to the tour's starting point to gently guide the path towards closure.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit by primarily minimizing the immediate travel distance\n    (like the greedy approach of Algo 2), but with a small weighted consideration\n    for the distance from the candidate node back to the tour's starting point,\n    inspired by the foresight component of Algo 1.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A small weighting factor for the distance from candidate to destination,\n    # significantly lower than W2 in Algo 1, to provide a subtle guidance.\n    W_return_foresight = 0.01 \n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (primary factor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Weighted distance from the candidate node back to the destination node\n        # (secondary, subtle foresight factor)\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine the immediate distance with the weighted foresight component\n        combined_cost = immediate_distance + (W_return_foresight * distance_to_destination_from_candidate)\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.01797,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next unvisited node by minimizing a proportionally weighted combined cost. It primarily prioritizes the immediate distance from the current node to a candidate, while subtly incorporating foresight by also considering the distance from the candidate node back to the tour's starting point with a much smaller weight (`W_blend = 0.025`).",
          "thought": "This algorithm refines the approach of Algorithm 2 by adopting Algorithm 1's proportional cost function, where immediate distance is still the primary factor, but the return-to-destination foresight is given a subtly increased and proportionally weighted influence to achieve a more optimized tour.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit by using a proportional weighting scheme (inspired by Algo 1)\n    that prioritizes immediate distance (similar to Algo 2) but gives a slightly more\n    pronounced, yet still subtle, influence to the distance from the candidate node back\n    to the tour's starting point.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # A weighting factor that is larger than Algo 2's 0.01 but smaller than Algo 1's 0.2,\n    # applying Algo 1's proportional weighting structure.\n    W_blend = 0.025 \n\n    for candidate_node in unvisited_nodes:\n        immediate_distance = distance_matrix[current_node][candidate_node]\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Combine immediate distance with the weighted distance from candidate back to destination.\n        # This formula (inspired by Algo 1) proportionally balances the two components,\n        # giving slightly more weight to foresight than Algo 2's additive approach.\n        combined_cost = (1 - W_blend) * immediate_distance + W_blend * distance_to_destination_from_candidate\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.06421,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm primarily selects the next unvisited node by minimizing immediate travel distance. It dynamically adjusts a return-to-start foresight component, increasing its influence as the tour progresses, and applies a minor penalty to prevent isolating other remaining unvisited nodes from the destination.",
          "thought": "This algorithm selects the next unvisited node by primarily minimizing immediate travel distance,\n    but dynamically adjusts the weight of a return-to-start foresight component based on the tour's progress,\n    and includes a penalty if selecting a candidate node significantly isolates the remaining unvisited nodes\n    from the destination.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    {This algorithm selects the next unvisited node by primarily minimizing immediate travel distance,\n    but dynamically adjusts the weight of a return-to-start foresight component based on the tour's progress,\n    and includes a penalty if selecting a candidate node significantly isolates the remaining unvisited nodes\n    from the destination.}\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    total_nodes = len(distance_matrix)\n    \n    # Calculate tour progress: as more nodes are visited, this factor increases from ~0 to 1.\n    # It represents the proportion of nodes already included in the tour.\n    # `total_nodes - len(unvisited_nodes)` is the count of nodes currently in the tour.\n    # We subtract 1 from total_nodes in denominator to avoid division by zero for N=1 case,\n    # and to correctly scale for tour of N nodes (N-1 steps).\n    nodes_in_tour_so_far = total_nodes - len(unvisited_nodes)\n    progress_factor = (nodes_in_tour_so_far / (total_nodes - 1)) if total_nodes > 1 else 1.0\n\n    # Dynamic weighting for the return-to-destination foresight.\n    # It starts at a base value and increases as the tour progresses towards completion,\n    # making the incentive to head towards the destination stronger at the end.\n    BASE_W_RETURN_FORESIGHT = 0.01\n    MAX_ADD_W_RETURN_FORESIGHT = 0.05\n    W_return_foresight = BASE_W_RETURN_FORESIGHT + (MAX_ADD_W_RETURN_FORESIGHT * progress_factor)\n\n    # A small weighting factor for the isolation penalty.\n    # This penalty discourages choices that leave remaining unvisited nodes very far from the destination.\n    W_isolation_penalty = 0.005 \n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (primary factor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Weighted distance from the candidate node back to the destination node (dynamic foresight component)\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n        foresight_cost = W_return_foresight * distance_to_destination_from_candidate\n\n        # 3. Isolation penalty: Considers the maximum distance from any *other* remaining unvisited node\n        #    back to the destination node, after `candidate_node` is selected.\n        #    This penalizes picking a node that \"strands\" other nodes far from the eventual return point.\n        other_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n        \n        isolation_penalty_cost = 0.0\n        if other_unvisited_after_candidate:\n            max_dist_others_to_destination = 0.0\n            for other_node in other_unvisited_after_candidate:\n                max_dist_others_to_destination = max(max_dist_others_to_destination, distance_matrix[other_node][destination_node])\n            \n            isolation_penalty_cost = W_isolation_penalty * max_dist_others_to_destination\n\n        # Combine all components to form the total cost for selecting this candidate node\n        combined_cost = immediate_distance + foresight_cost + isolation_penalty_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.09537,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by minimizing a combined cost that primarily considers the immediate travel distance. This cost is dynamically adjusted by a \"foresight\" component, which increasingly prioritizes candidates closer to the destination node as the tour progresses, and a subtle penalty for candidates poorly connected to other remaining unvisited locations. This approach aims to balance immediate path efficiency with progressive tour closure and overall connectivity.",
          "thought": "This algorithm dynamically adjusts the foresight weight for the return path based on tour progress, while also incorporating a subtle connectivity penalty that considers the candidate node's average distance to other remaining unvisited nodes, aiming for a balanced and progressively closing tour.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit by dynamically adjusting the foresight weight based on\n    tour progress and incorporating a subtle connectivity penalty.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    num_total_nodes = len(distance_matrix)\n\n    # --- Dynamic Foresight Weighting Mechanism ---\n    # `num_steps_completed` is the number of edges already added to the tour path,\n    # excluding the very first implicit step from destination_node to the first actual current_node.\n    # A full tour has `num_total_nodes` edges.\n    # The total number of intermediate nodes to choose is `num_total_nodes - 1`.\n    num_steps_completed = num_total_nodes - len(unvisited_nodes) - 1\n    \n    # Calculate progress ratio for dynamic weighting\n    progress_ratio = 0.0\n    if num_total_nodes > 1:\n        # Scale progress from 0.0 (start of selecting intermediate nodes) to 1.0 (last intermediate node selected)\n        progress_ratio = max(0.0, min(1.0, num_steps_completed / (num_total_nodes - 1)))\n    \n    # Base weight for return foresight, similar to original algorithm\n    W_base_foresight = 0.01 \n    # Maximum additional weight for foresight, making it increase as the tour progresses\n    W_max_increase_foresight = 0.04 # Foresight weight will range from 0.01 to 0.05\n\n    dynamic_foresight_weight = W_base_foresight + (W_max_increase_foresight * progress_ratio)\n\n    # --- Connectivity Penalty Mechanism ---\n    # A small constant weight for penalizing nodes poorly connected to other remaining unvisited nodes.\n    W_connectivity_penalty = 0.005 \n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost from current_node to candidate_node (primary factor)\n        immediate_distance = distance_matrix[current_node][candidate_node]\n\n        # 2. Weighted distance from the candidate node back to the destination node (dynamic foresight)\n        distance_to_destination_from_candidate = distance_matrix[candidate_node][destination_node]\n        foresight_cost = dynamic_foresight_weight * distance_to_destination_from_candidate\n\n        # 3. Connectivity penalty: calculate average distance from candidate to other remaining unvisited nodes\n        connectivity_penalty_cost = 0.0\n        other_unvisited_excluding_candidate = [n for n in unvisited_nodes if n != candidate_node]\n        \n        if other_unvisited_excluding_candidate:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_excluding_candidate)\n            avg_dist_to_others = sum_dist_to_others / len(other_unvisited_excluding_candidate)\n            connectivity_penalty_cost = W_connectivity_penalty * avg_dist_to_others\n        # If `other_unvisited_excluding_candidate` is empty, `connectivity_penalty_cost` remains 0.0,\n        # which is appropriate as there are no other nodes to consider for connectivity.\n\n        # Combine the immediate distance with the dynamic foresight and connectivity components\n        combined_cost = immediate_distance + foresight_cost + connectivity_penalty_cost\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.12771,
          "other_inf": null
     }
]