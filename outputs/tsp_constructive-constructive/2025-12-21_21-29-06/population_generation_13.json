[
     {
          "algorithm": "This greedy heuristic constructs a TSP tour by iteratively selecting the unvisited node with the minimum distance from the current position. The path extends in this nearest-neighbor fashion until all other nodes have been visited, at which point the algorithm completes the cycle by returning to the designated starting node.",
          "thought": "The algorithm constructs the tour by iteratively selecting the unvisited node closest to the current node, completing the cycle by returning to the starting node when all other nodes have been visited.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on the greedy (nearest neighbor) heuristic.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_distance = math.inf\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n\n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm extends the nearest-neighbor approach by selecting the next unvisited node based on a combined score. This score weights the direct distance from the current node more heavily than its proximity to the designated starting node (with a `bias_factor` of 0.5), aiming for an overall shorter path that efficiently returns to the origin.",
          "thought": "This algorithm modifies the nearest-neighbor approach by selecting the next node based on a combined score of its direct distance from the current node and its proximity to the designated starting node, aiming to create a more globally informed path.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a nearest-neighbor approach biased by\n    proximity to the destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_biased_distance = math.inf\n    bias_factor = 0.5  # Controls the weight of the destination proximity\n\n    for node in unvisited_nodes:\n        # Calculate direct distance from current to candidate node\n        direct_distance = distance_matrix[current_node][node]\n        # Calculate heuristic distance from candidate node to the destination node\n        distance_to_destination = distance_matrix[node][destination_node]\n\n        # Combine distances with a bias factor\n        # The goal is to prefer nodes that are not only close now but also lead to a\n        # path that potentially finishes closer to the start.\n        biased_distance = direct_distance + (distance_to_destination * bias_factor)\n\n        if biased_distance < min_biased_distance:\n            min_biased_distance = biased_distance\n            next_node = node\n\n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic enhances the Nearest Neighbor approach by selecting the next node based on a \"combined cost.\" For each potential next node, this cost is calculated as the immediate distance from the current node plus a weighted look-ahead. The look-ahead component represents the minimum distance from that potential node to any *other* remaining unvisited node, with a factor `K` determining its priority in the selection.",
          "thought": "This algorithm enhances the nearest neighbor approach by introducing a look-ahead mechanism, where the selection of the next node is based not only on its immediate proximity to the current node but also on the minimum distance from that potential next node to any other remaining unvisited node, effectively minimizing a weighted sum of the first two steps of the path.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit based on a modified Nearest Neighbor heuristic\n    that considers immediate distance and a look-ahead for the next step.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_combined_cost = math.inf\n\n    # Weighting factor for the look-ahead distance (0 <= K <= 1)\n    # K=0 reverts to pure Nearest Neighbor. K=1 weighs both steps equally.\n    K = 0.5 \n\n    for candidate_node in unvisited_nodes:\n        # Step 1: Calculate the immediate cost to move from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Step 2: Calculate the minimum future distance from candidate_node to another remaining unvisited node\n        # This is a one-step look-ahead from the perspective of the candidate_node.\n        min_future_dist = math.inf\n        remaining_unvisited_after_candidate = unvisited_nodes - {candidate_node}\n\n        if not remaining_unvisited_after_candidate:\n            # If candidate_node is the last remaining unvisited node, the next step must be to the destination_node\n            min_future_dist = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the closest node from candidate_node among the *remaining* unvisited nodes\n            for future_node in remaining_unvisited_after_candidate:\n                future_distance = distance_matrix[candidate_node][future_node]\n                if future_distance < min_future_dist:\n                    min_future_dist = future_distance\n        \n        # New equation: Combine immediate cost with the weighted future look-ahead distance\n        # This gives preference to paths that are not only immediately close but also lead to good future options.\n        combined_cost = immediate_cost + K * min_future_dist\n\n        if combined_cost < min_combined_cost:\n            min_combined_cost = combined_cost\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.45538,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next unvisited node by minimizing a composite score. This score equally combines the immediate travel distance from the current node with the direct distance from the candidate node back to the tour's destination, aiming to simplify overall path completion.",
          "thought": "This heuristic selects the next node by minimizing a score that equally combines the immediate travel distance from the current node with the direct distance from the candidate node back to the tour's destination, thus prioritizing a straightforward path completion.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using an Immediate and Return Proximity heuristic.\n    This heuristic considers both the immediate distance to a candidate node\n    and the direct distance from that candidate node to the final destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_total_score = math.inf\n\n    for candidate_node in unvisited_nodes:\n        # Calculate the immediate cost to travel from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n        \n        # Calculate the direct cost to return to the destination from the candidate_node.\n        # This term helps prioritize candidates that are also 'close' to the final destination,\n        # simplifying the closure of the tour.\n        return_cost_to_destination = distance_matrix[candidate_node][destination_node]\n        \n        # The total score is the sum of the immediate cost and the cost to return\n        # to the destination from this candidate node.\n        total_score = immediate_cost + return_cost_to_destination\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = candidate_node\n\n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by evaluating a two-step lookahead cost: the immediate travel distance to a candidate node plus the minimum possible distance from that candidate to any subsequent unvisited node or the tour's destination. It minimizes this composite score to choose a path that is short both immediately and for the projected next leg.",
          "thought": "This heuristic selects the next node by minimizing a composite score formed by the immediate travel distance to the candidate node plus the minimum distance from that candidate node to any other remaining unvisited node or the final destination, effectively performing a two-step lookahead.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a Two-Step Minimum Cost heuristic.\n    This heuristic considers the immediate distance to a candidate node and\n    then estimates the best possible next step from that candidate node\n    (either to another unvisited node or directly to the destination).\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_total_score = math.inf\n\n    for candidate_node in unvisited_nodes:\n        # Calculate the immediate cost to travel from current_node to candidate_node\n        immediate_cost = distance_matrix[current_node][candidate_node]\n        \n        # Calculate the minimum cost for the *next* step from the candidate_node.\n        # This looks for the shortest path from candidate_node to any other\n        # remaining unvisited node or directly to the destination.\n        \n        min_cost_from_candidate_to_next = math.inf\n        \n        # Consider all other unvisited nodes as potential next steps\n        for next_possible_target in unvisited_nodes:\n            if next_possible_target != candidate_node:\n                min_cost_from_candidate_to_next = min(\n                    min_cost_from_candidate_to_next,\n                    distance_matrix[candidate_node][next_possible_target]\n                )\n        \n        # Always consider returning to the destination as a possible next step from candidate_node.\n        # This handles the case where candidate_node is the last unvisited node,\n        # or if returning to destination is the shortest path from candidate_node.\n        min_cost_from_candidate_to_next = min(\n            min_cost_from_candidate_to_next,\n            distance_matrix[candidate_node][destination_node]\n        )\n        \n        # The total score is the sum of the immediate cost and the estimated minimum cost for the next step.\n        total_score = immediate_cost + min_cost_from_candidate_to_next\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = candidate_node\n\n    return next_node",
          "objective": 8.31433,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by minimizing a score that equally combines the immediate travel distance from the current node with the average distance from the candidate node to all subsequent unvisited nodes and the tour's destination. This method balances short-term proximity with an estimation of future connectivity to construct the tour.",
          "thought": "This algorithm selects the next node by minimizing a combined score of the immediate travel distance from the current node and the average distance from the candidate node to all remaining unvisited nodes, including the final destination node.",
          "code": "import math\n\ndef select_next_node(current_node: int, destination_node: int, unvisited_nodes: set[int], distance_matrix: list[list[float]]) -> int:\n    \"\"\"\n    Selects the next node to visit using a Balanced Connectivity heuristic.\n    This heuristic considers both the immediate distance to a candidate node\n    and the average distance from that candidate to all other remaining\n    unvisited nodes and the final destination node.\n\n    Args:\n        current_node: The node currently at.\n        destination_node: The starting node of the tour, to which the path must return.\n        unvisited_nodes: A set of nodes that have not yet been visited.\n        distance_matrix: A 2D list (matrix) where distance_matrix[i][j]\n                         is the distance between node i and node j.\n\n    Returns:\n        The next node to visit.\n    \"\"\"\n    if not unvisited_nodes:\n        # If all other nodes have been visited, return to the destination node (start node)\n        return destination_node\n\n    next_node = -1\n    min_total_score = math.inf\n\n    for candidate_node in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate_node]\n\n        if len(unvisited_nodes) == 1:\n            # If this is the last unvisited node, the final leg is to destination_node\n            total_score = direct_cost + distance_matrix[candidate_node][destination_node]\n        else:\n            # Calculate an average \"future connectivity\" cost from the candidate_node\n            sum_future_distances = 0.0\n            count_future_nodes = 0\n\n            # Add distances to all other unvisited nodes\n            for other_unvisited in unvisited_nodes:\n                if other_unvisited != candidate_node:\n                    sum_future_distances += distance_matrix[candidate_node][other_unvisited]\n                    count_future_nodes += 1\n            \n            # Add distance to the destination node\n            sum_future_distances += distance_matrix[candidate_node][destination_node]\n            count_future_nodes += 1\n            \n            average_future_cost = sum_future_distances / count_future_nodes\n            \n            # The total score is the direct cost plus this average future cost\n            total_score = direct_cost + average_future_cost\n\n        if total_score < min_total_score:\n            min_total_score = total_score\n            next_node = candidate_node\n\n    return next_node",
          "objective": 8.4729,
          "other_inf": null
     }
]