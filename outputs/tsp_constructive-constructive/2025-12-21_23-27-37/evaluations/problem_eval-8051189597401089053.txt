def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    best_next_node = None
    min_lookahead_score = float('inf')

    if not unvisited_nodes:
        return None

    # If only one node is left, it is the only choice.
    if len(unvisited_nodes) == 1:
        return list(unvisited_nodes)[0]

    # Evaluate each unvisited node as a potential next step.
    for candidate_node in unvisited_nodes:
        # Cost of the first edge: current -> candidate
        cost_to_candidate = distance_matrix[current_node][candidate_node]

        # Lookahead part: Find the cost of the second edge (candidate -> its nearest neighbor)
        cost_from_candidate = float('inf')
        other_unvisited_nodes = unvisited_nodes - {candidate_node}

        if not other_unvisited_nodes:
            # This case occurs when only one candidate is left in unvisited_nodes.
            # Its lookahead cost can be considered zero.
            cost_from_candidate = 0
        else:
            for second_step_node in other_unvisited_nodes:
                dist = distance_matrix[candidate_node][second_step_node]
                if dist < cost_from_candidate:
                    cost_from_candidate = dist
        
        # The score combines the immediate cost and the lookahead cost.
        lookahead_score = cost_to_candidate + cost_from_candidate

        if lookahead_score < min_lookahead_score:
            min_lookahead_score = lookahead_score
            best_next_node = candidate_node
            
    return next_node
