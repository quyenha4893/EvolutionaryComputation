def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    next_node = None
    best_score = float('inf')

    if not unvisited_nodes:
        return None

    # Weights for the three-part scoring function.
    # alpha: Prioritizes immediate nearest neighbor (greedy).
    # beta: Prioritizes a good one-step lookahead (from Algo 2).
    # gamma: Prioritizes proximity to the destination (from Algo 1).
    alpha = 0.7
    beta = 0.2
    gamma = 0.1

    for candidate_node in unvisited_nodes:
        # Part 1: Immediate cost (distance from current to candidate).
        immediate_cost = distance_matrix[current_node][candidate_node]

        # Part 2: One-step lookahead cost (distance from candidate to its own nearest unvisited neighbor).
        remaining_nodes = unvisited_nodes - {candidate_node}
        if not remaining_nodes:
            # If candidate is the last unvisited node, this cost is the distance back to the start.
            one_step_lookahead_cost = distance_matrix[candidate_node][destination_node]
        else:
            one_step_lookahead_cost = min(distance_matrix[candidate_node][other] for other in remaining_nodes)
            
        # Part 3: Return journey cost (distance from candidate to destination).
        return_cost = distance_matrix[candidate_node][destination_node]

        # Composite score using the three weighted components.
        score = (alpha * immediate_cost) + (beta * one_step_lookahead_cost) + (gamma * return_cost)

        if score < best_score:
            best_score = score
            next_node = candidate_node
            
    return next_node
