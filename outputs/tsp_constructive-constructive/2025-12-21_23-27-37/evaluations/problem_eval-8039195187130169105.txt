def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    """
    Selects the next node using a two-step lookahead. It evaluates each candidate
    by summing the cost to reach it and the cost of the best possible next move
    from that candidate to another unvisited node. This helps to avoid moves
    that lead to costly subsequent steps.
    """
    next_node = None
    best_score = float('inf')

    if not unvisited_nodes:
        return None

    # If only one unvisited node is left, it's the only choice.
    if len(unvisited_nodes) == 1:
        return list(unvisited_nodes)[0]

    # Iterate through each potential next node to evaluate it.
    for candidate_node in unvisited_nodes:
        # Cost of the first step (current -> candidate).
        cost_step1 = distance_matrix[current_node][candidate_node]
        
        # Find the cost of the best second step (candidate -> ?).
        cost_step2 = float('inf')
        nodes_for_step2 = unvisited_nodes - {candidate_node}
        
        # The best second step is to the nearest of the *remaining* unvisited nodes.
        for next_hop_node in nodes_for_step2:
            dist = distance_matrix[candidate_node][next_hop_node]
            if dist < cost_step2:
                cost_step2 = dist
        
        # The score for the candidate is the sum of the two steps.
        total_lookahead_cost = cost_step1 + cost_step2
        
        if total_lookahead_cost < best_score:
            best_score = total_lookahead_cost
            next_node = candidate_node
            
    return next_node
