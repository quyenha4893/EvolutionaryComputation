[
     {
          "algorithm": "This algorithm implements a greedy Nearest Neighbor heuristic, constructing the tour by iteratively selecting the absolute closest unvisited node from the current location. The selection logic solely prioritizes minimizing the immediate distance to the next node, completely ignoring the final destination node during the construction process.",
          "thought": "The algorithm constructs a tour by starting at an arbitrary node and repeatedly visiting the closest unvisited node until all nodes are visited, finally returning to the start.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    shortest_distance = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        distance = distance_matrix[current_node][candidate_node]\n        if distance < shortest_distance:\n            shortest_distance = distance\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm enhances the greedy nearest neighbor approach by selecting the next node based on a weighted score that balances immediate and future costs. The score heavily prioritizes the immediate distance from the current node to a candidate (80% weight), while also incorporating a smaller, one-step lookahead cost represented by the distance from that candidate to its own nearest unvisited neighbor (20% weight). This method favors nodes that are not only close now but also offer a promising subsequent move.",
          "thought": "The new algorithm enhances the greedy nearest neighbor approach by evaluating each candidate not only on its immediate distance but also on the distance to its own nearest neighbor among the remaining unvisited nodes, using a weighted score to select the candidate that offers the most promising two-step path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is set to 0.8 to heavily prioritize the immediate neighbor (inspired by Algo 2's success)\n    # but includes a 20% weight for a one-step lookahead cost (a refined version of Algo 1's concept).\n    alpha = 0.8\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future cost, defined as the distance from the candidate to its own nearest neighbor.\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        \n        min_dist_from_candidate = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, the future cost is the distance back to the start.\n            min_dist_from_candidate = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < min_dist_from_candidate:\n                    min_dist_from_candidate = distance\n        \n        # The score balances the immediate move with the quality of the subsequent move.\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * min_dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.20148,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a composite score that considers the immediate travel cost, the candidate's centrality to remaining nodes, and the final return cost. Critically, it employs dynamic weights that shift the heuristic's priority based on tour progress: it starts by emphasizing central nodes to build a good tour structure, then transitions to a more greedy strategy that favors the nearest neighbor as the tour nears completion.",
          "thought": "This algorithm selects the next node using a score that dynamically balances immediate travel cost, the candidate's centrality among remaining nodes, and the final return cost, by adjusting weighting factors based on the tour's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n\n    # Determine the total number of nodes and the current progress of the tour\n    total_nodes = len(distance_matrix)\n    num_unvisited = len(unvisited_nodes)\n    \n    # Progress is a ratio of visited nodes to total nodes, influencing the weights.\n    # It ranges from (approx) 0.0 at the start to 1.0 at the end.\n    progress = 1.0 - (num_unvisited / (total_nodes - 1)) if total_nodes > 1 else 1.0\n\n    # --- Dynamic Weighting Parameters ---\n    # alpha: Weight for immediate cost. Increases as the tour progresses, making the\n    # choice more greedy towards the end. (Ranges from 0.5 to 1.0)\n    alpha = 0.5 + (0.5 * progress)\n\n    # beta: Weight for centrality. Decreases as the tour progresses. Prioritizes\n    # visiting nodes central to the remaining cluster early on. (Ranges from 0.3 to 0.0)\n    beta = 0.3 * (1.0 - progress)\n\n    # gamma: Weight for the final return cost. It takes the remaining portion.\n    gamma = 1.0 - alpha - beta\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Immediate Cost (current -> candidate)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Component 2: Centrality Cost (candidate's avg distance to other unvisited nodes)\n        other_unvisited = unvisited_nodes - {candidate_node}\n        if other_unvisited:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            centrality_cost = sum_dist_to_others / len(other_unvisited)\n        else:\n            # If this is the last node, its centrality cost is zero.\n            centrality_cost = 0\n\n        # Component 3: Final Return Cost (candidate -> destination)\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the dynamically adjusted weights\n        score = (alpha * dist_to_candidate) + (beta * centrality_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    # Fallback for the very last node, though the loop should find it.\n    if next_node is None and unvisited_nodes:\n        return list(unvisited_nodes)[0]\n\n    return next_node",
          "objective": 7.34673,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score for each unvisited candidate and choosing the one with the minimum score. Using a fixed `alpha` parameter of 0.7, the scoring function heavily prioritizes the immediate distance from the current node (70% weight) over the future distance from the candidate back to the final destination (30% weight).",
          "thought": "This algorithm implements a weighted greedy heuristic that selects the next node by calculating a score for each candidate that balances the immediate distance from the current node against the candidate's distance to the final destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is a weighting factor. A value of 1.0 makes this equivalent to the standard nearest neighbor.\n    # A value of 0.0 would always choose the unvisited node closest to the destination.\n    # A value of 0.7 prioritizes the nearest neighbor but also considers the return journey.\n    alpha = 0.7\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Distance from the current node to the candidate (immediate cost)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Distance from the candidate to the final destination (future cost)\n        dist_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Weighted score equation to balance immediate and future costs\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node by calculating a composite score for each candidate, heavily prioritizing the immediate travel cost (alpha=0.6) for a primarily greedy selection. This greedy choice is then refined by two secondary factors: the candidate's average distance to remaining unvisited nodes and its distance back to the destination, which help avoid selecting isolated nodes far from the main cluster or the end point.",
          "thought": "This algorithm selects the next node by calculating a composite score that balances the immediate travel cost (alpha), the candidate's average distance to all other unvisited nodes (beta), and the final return distance (gamma).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three-part scoring function.\n    # alpha: Prioritizes immediate nearest neighbor (greedy).\n    # beta: Prioritizes candidates that are centrally located to other unvisited nodes (look-ahead).\n    # gamma: Prioritizes candidates that are closer to the final destination (end-game).\n    alpha = 0.6\n    beta = 0.2\n    gamma = 0.2\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost (distance from current to candidate).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future outlook cost (average distance from candidate to all OTHER unvisited nodes).\n        # This penalizes nodes that are \"isolated\" from the remaining cluster of unvisited nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        if not other_unvisited_nodes:\n            # If the candidate is the last unvisited node, this cost is zero.\n            future_outlook_cost = 0.0\n        else:\n            total_future_dist = sum(distance_matrix[candidate_node][other_node] for other_node in other_unvisited_nodes)\n            future_outlook_cost = total_future_dist / len(other_unvisited_nodes)\n            \n        # Part 3: Return journey cost (distance from candidate to destination).\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the three weighted components.\n        score = (alpha * immediate_cost) + (beta * future_outlook_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.72489,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm greedily selects the next node by minimizing a \"detour\" cost, which is calculated as the sum of the distance from the current node to a candidate and the distance from that candidate back to the starting destination. By choosing the candidate with the lowest score, the heuristic strategically balances the immediate cost of reaching a new node with the future cost of returning to the origin.",
          "thought": "This algorithm selects the next node by choosing the candidate which minimizes the sum of two distances: the distance from the current node to the candidate, and the distance from the candidate to the starting destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node based on a score that balances the distance from the current node\n    and the distance to the final destination. This is a variant of the cheapest insertion\n    heuristic applied sequentially, choosing the node that creates the smallest \"detour\".\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # The score is the sum of the distance to the candidate and from the candidate back to the start.\n        # This considers the cost of the \"detour\" through the candidate node.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        score = dist_to_candidate + dist_from_candidate_to_dest\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs a two-step lookahead heuristic, selecting the next node not just by its proximity, but by which one offers the best onward path. It prioritizes the choice that minimizes the sum of the immediate travel cost plus the cost of the cheapest subsequent move to another unvisited node, effectively avoiding moves that lead to isolated, high-cost nodes later in the tour.",
          "thought": "This algorithm uses a two-step lookahead approach, choosing the next node by minimizing the combined cost of the immediate step and the best possible subsequent step to another unvisited node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a two-step lookahead. It evaluates each candidate\n    by summing the cost to reach it and the cost of the best possible next move\n    from that candidate to another unvisited node. This helps to avoid moves\n    that lead to costly subsequent steps.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # If only one unvisited node is left, it's the only choice.\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    # Iterate through each potential next node to evaluate it.\n    for candidate_node in unvisited_nodes:\n        # Cost of the first step (current -> candidate).\n        cost_step1 = distance_matrix[current_node][candidate_node]\n        \n        # Find the cost of the best second step (candidate -> ?).\n        cost_step2 = float('inf')\n        nodes_for_step2 = unvisited_nodes - {candidate_node}\n        \n        # The best second step is to the nearest of the *remaining* unvisited nodes.\n        for next_hop_node in nodes_for_step2:\n            dist = distance_matrix[candidate_node][next_hop_node]\n            if dist < cost_step2:\n                cost_step2 = dist\n        \n        # The score for the candidate is the sum of the two steps.\n        total_lookahead_cost = cost_step1 + cost_step2\n        \n        if total_lookahead_cost < best_score:\n            best_score = total_lookahead_cost\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by minimizing a composite score that balances two equally weighted criteria. The score for each candidate node is the sum of its distance from the current node and its average distance to all other unvisited nodes. This method simultaneously prioritizes nodes that are both immediately close and centrally located with respect to the remaining set of unvisited points.",
          "thought": "This algorithm selects the next node by minimizing a score calculated as the ratio of the distance to a candidate node over that candidate's average distance to all other unvisited nodes, effectively choosing a node that is both close and centrally located among the remaining options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by balancing its proximity to the current node with its\n    centrality to the rest of the unvisited nodes. The heuristic aims to avoid\n    moving to an isolated node, even if it is the closest one.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # If only one unvisited node is left, it's the only choice.\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    for candidate_node in unvisited_nodes:\n        # Distance from the current node to the potential next node.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Calculate the candidate's average distance to all OTHER unvisited nodes.\n        sum_of_dists_to_others = 0\n        other_unvisited = unvisited_nodes - {candidate_node}\n        \n        for other_node in other_unvisited:\n            sum_of_dists_to_others += distance_matrix[candidate_node][other_node]\n        \n        # This will not be zero since we handled the case of len(unvisited_nodes) == 1.\n        avg_dist_to_others = sum_of_dists_to_others / len(other_unvisited)\n        \n        # The score is a ratio. Lower is better.\n        # It prioritizes nodes that are close (low numerator) and/or\n        # are centrally located to other unvisited nodes (low denominator implies it's far from others, so we want a high denominator).\n        # Ah, logic error in thought process. A centrally located node would have a LOW average distance.\n        # So we want dist_to_candidate to be low and avg_dist_to_others to be low.\n        # Let's change the score to a sum, as it's more stable and represents a combined cost.\n        # Let's use the product to balance scales.\n        # Let's stick to the ratio, but a different one. A good candidate is close to current AND close to the rest of the points.\n        # So, we need to pick the node that minimizes dist_to_candidate and avg_dist_to_others.\n        # The original ratio dist/avg favors nodes that are far from others. Let's use dist * avg.\n        # No, let's go with the initial description's logic. A node is \"central\" if its average distance to others is low.\n        # We want to pick a node that is close (low dist_to_candidate) and central (low avg_dist_to_others).\n        # A simple sum combines these two goals. This creates a new heuristic different from the others.\n        \n        score = dist_to_candidate + avg_dist_to_others\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs a dynamic weighting strategy to select the next node by calculating a score that balances two factors: the immediate distance to a candidate node and that candidate's distance back to the final destination. The weighting factor, `alpha`, is proportional to the number of remaining unvisited nodes, ensuring the selection initially prioritizes the nearest neighbor (a greedy approach) but progressively shifts to favor nodes closer to the destination as the tour nears its end.",
          "thought": "This algorithm creates a dynamic weighted score by making the alpha parameter proportional to the number of remaining unvisited nodes, thus starting with a highly greedy focus like the first algorithm and progressively increasing consideration for the final destination as the tour nears completion.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Dynamically adjust alpha based on tour progress.\n    # The denominator represents the initial number of nodes to visit.\n    # We use len(distance_matrix) - 1, assuming the tour visits all nodes.\n    initial_unvisited_count = len(distance_matrix) - 1\n    if initial_unvisited_count > 0:\n        alpha = len(unvisited_nodes) / initial_unvisited_count\n    else:\n        alpha = 1.0 # Fallback for edge cases\n\n    for candidate_node in unvisited_nodes:\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        dist_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # The score is heavily weighted towards the nearest neighbor at the start (high alpha)\n        # and shifts focus towards the destination as the tour progresses (low alpha).\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.89041,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm constructs a tour by selecting the next node based on a weighted sum of two distances: the distance from the current node and the distance to the final destination. A dynamic weighting parameter, `alpha`, is calculated based on the proportion of remaining unvisited nodes, causing the selection to transition from a greedy nearest-neighbor strategy at the start to one that prioritizes proximity to the destination as the tour concludes.",
          "thought": "This algorithm uses a dynamic weighting parameter that decreases as the tour progresses, initially prioritizing the nearest neighbor and later focusing on minimizing the distance back to the destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a dynamic weighting factor 'alpha' that adapts\n    based on the number of remaining unvisited nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    total_nodes = len(distance_matrix)\n    \n    # Alpha is now dynamic. It changes based on the progress of the tour.\n    # It is calculated as the ratio of remaining choices to the total number of choices.\n    # When many nodes are unvisited, alpha is high (close to 1), prioritizing the nearest neighbor.\n    # As the tour nears completion (few unvisited nodes), alpha becomes low (close to 0),\n    # prioritizing the node closest to the final destination.\n    # We handle the case where total_nodes <= 2 to avoid division by zero.\n    if total_nodes > 2:\n        # The number of choices to be made is total_nodes - 2 (excluding start and end).\n        # The number of remaining choices is len(unvisited_nodes) - 1.\n        alpha = (len(unvisited_nodes) - 1) / (total_nodes - 2)\n    else:\n        # For trivial cases, default to a greedy choice.\n        alpha = 1.0\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Distance from the current node to the candidate\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Distance from the candidate to the final destination\n        dist_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Dynamic weighted score\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.94829,
          "other_inf": null
     }
]