[
     {
          "algorithm": "This algorithm implements a greedy Nearest Neighbor heuristic, constructing the tour by iteratively selecting the absolute closest unvisited node from the current location. The selection logic solely prioritizes minimizing the immediate distance to the next node, completely ignoring the final destination node during the construction process.",
          "thought": "The algorithm constructs a tour by starting at an arbitrary node and repeatedly visiting the closest unvisited node until all nodes are visited, finally returning to the start.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    shortest_distance = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        distance = distance_matrix[current_node][candidate_node]\n        if distance < shortest_distance:\n            shortest_distance = distance\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score for each unvisited candidate and choosing the one with the minimum score. Using a fixed `alpha` parameter of 0.7, the scoring function heavily prioritizes the immediate distance from the current node (70% weight) over the future distance from the candidate back to the final destination (30% weight).",
          "thought": "This algorithm implements a weighted greedy heuristic that selects the next node by calculating a score for each candidate that balances the immediate distance from the current node against the candidate's distance to the final destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is a weighting factor. A value of 1.0 makes this equivalent to the standard nearest neighbor.\n    # A value of 0.0 would always choose the unvisited node closest to the destination.\n    # A value of 0.7 prioritizes the nearest neighbor but also considers the return journey.\n    alpha = 0.7\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Distance from the current node to the candidate (immediate cost)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Distance from the candidate to the final destination (future cost)\n        dist_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Weighted score equation to balance immediate and future costs\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm greedily selects the next node by minimizing a \"detour\" cost, which is calculated as the sum of the distance from the current node to a candidate and the distance from that candidate back to the starting destination. By choosing the candidate with the lowest score, the heuristic strategically balances the immediate cost of reaching a new node with the future cost of returning to the origin.",
          "thought": "This algorithm selects the next node by choosing the candidate which minimizes the sum of two distances: the distance from the current node to the candidate, and the distance from the candidate to the starting destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node based on a score that balances the distance from the current node\n    and the distance to the final destination. This is a variant of the cheapest insertion\n    heuristic applied sequentially, choosing the node that creates the smallest \"detour\".\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # The score is the sum of the distance to the candidate and from the candidate back to the start.\n        # This considers the cost of the \"detour\" through the candidate node.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        score = dist_to_candidate + dist_from_candidate_to_dest\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs a two-step lookahead heuristic, selecting the next node not just by its proximity, but by which one offers the best onward path. It prioritizes the choice that minimizes the sum of the immediate travel cost plus the cost of the cheapest subsequent move to another unvisited node, effectively avoiding moves that lead to isolated, high-cost nodes later in the tour.",
          "thought": "This algorithm uses a two-step lookahead approach, choosing the next node by minimizing the combined cost of the immediate step and the best possible subsequent step to another unvisited node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a two-step lookahead. It evaluates each candidate\n    by summing the cost to reach it and the cost of the best possible next move\n    from that candidate to another unvisited node. This helps to avoid moves\n    that lead to costly subsequent steps.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # If only one unvisited node is left, it's the only choice.\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    # Iterate through each potential next node to evaluate it.\n    for candidate_node in unvisited_nodes:\n        # Cost of the first step (current -> candidate).\n        cost_step1 = distance_matrix[current_node][candidate_node]\n        \n        # Find the cost of the best second step (candidate -> ?).\n        cost_step2 = float('inf')\n        nodes_for_step2 = unvisited_nodes - {candidate_node}\n        \n        # The best second step is to the nearest of the *remaining* unvisited nodes.\n        for next_hop_node in nodes_for_step2:\n            dist = distance_matrix[candidate_node][next_hop_node]\n            if dist < cost_step2:\n                cost_step2 = dist\n        \n        # The score for the candidate is the sum of the two steps.\n        total_lookahead_cost = cost_step1 + cost_step2\n        \n        if total_lookahead_cost < best_score:\n            best_score = total_lookahead_cost\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.38246,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by minimizing a composite score that balances two equally weighted criteria. The score for each candidate node is the sum of its distance from the current node and its average distance to all other unvisited nodes. This method simultaneously prioritizes nodes that are both immediately close and centrally located with respect to the remaining set of unvisited points.",
          "thought": "This algorithm selects the next node by minimizing a score calculated as the ratio of the distance to a candidate node over that candidate's average distance to all other unvisited nodes, effectively choosing a node that is both close and centrally located among the remaining options.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by balancing its proximity to the current node with its\n    centrality to the rest of the unvisited nodes. The heuristic aims to avoid\n    moving to an isolated node, even if it is the closest one.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # If only one unvisited node is left, it's the only choice.\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    for candidate_node in unvisited_nodes:\n        # Distance from the current node to the potential next node.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Calculate the candidate's average distance to all OTHER unvisited nodes.\n        sum_of_dists_to_others = 0\n        other_unvisited = unvisited_nodes - {candidate_node}\n        \n        for other_node in other_unvisited:\n            sum_of_dists_to_others += distance_matrix[candidate_node][other_node]\n        \n        # This will not be zero since we handled the case of len(unvisited_nodes) == 1.\n        avg_dist_to_others = sum_of_dists_to_others / len(other_unvisited)\n        \n        # The score is a ratio. Lower is better.\n        # It prioritizes nodes that are close (low numerator) and/or\n        # are centrally located to other unvisited nodes (low denominator implies it's far from others, so we want a high denominator).\n        # Ah, logic error in thought process. A centrally located node would have a LOW average distance.\n        # So we want dist_to_candidate to be low and avg_dist_to_others to be low.\n        # Let's change the score to a sum, as it's more stable and represents a combined cost.\n        # Let's use the product to balance scales.\n        # Let's stick to the ratio, but a different one. A good candidate is close to current AND close to the rest of the points.\n        # So, we need to pick the node that minimizes dist_to_candidate and avg_dist_to_others.\n        # The original ratio dist/avg favors nodes that are far from others. Let's use dist * avg.\n        # No, let's go with the initial description's logic. A node is \"central\" if its average distance to others is low.\n        # We want to pick a node that is close (low dist_to_candidate) and central (low avg_dist_to_others).\n        # A simple sum combines these two goals. This creates a new heuristic different from the others.\n        \n        score = dist_to_candidate + avg_dist_to_others\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     }
]