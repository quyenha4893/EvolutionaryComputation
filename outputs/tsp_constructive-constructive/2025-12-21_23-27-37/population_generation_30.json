[
     {
          "algorithm": "This algorithm implements a greedy Nearest Neighbor heuristic, constructing the tour by iteratively selecting the absolute closest unvisited node from the current location. The selection logic solely prioritizes minimizing the immediate distance to the next node, completely ignoring the final destination node during the construction process.",
          "thought": "The algorithm constructs a tour by starting at an arbitrary node and repeatedly visiting the closest unvisited node until all nodes are visited, finally returning to the start.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    shortest_distance = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        distance = distance_matrix[current_node][candidate_node]\n        if distance < shortest_distance:\n            shortest_distance = distance\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node using a weighted scoring system that predominantly follows a greedy approach, assigning an 85% priority to the immediate distance from the current node. The algorithm refines this greedy choice by incorporating two lower-priority lookahead factors: a 10% weight for the distance to the candidate's own nearest neighbor and a 5% weight for the distance back to the final destination. This balanced method aims to avoid poor local choices while maintaining a general direction towards the tour's end.",
          "thought": "This algorithm selects the next node using a three-part weighted score that heavily prioritizes immediate distance (85%), while also considering a short-term one-step lookahead to the next nearest neighbor (10%) and a long-range pull towards the final destination (5%).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three components, prioritizing the greedy choice while adding smarter lookaheads.\n    w_immediate = 0.85         # Inspired by the success of the greedy approach (Algo 3).\n    w_short_lookahead = 0.10   # Inspired by the refined lookahead of Algo 2.\n    w_long_lookahead = 0.05    # Inspired by the destination-aware heuristic of Algo 1.\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate (from Algo 3).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Short-term lookahead cost, i.e., distance from the candidate to its own nearest neighbor (from Algo 2).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        short_lookahead_cost = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, its 'next step' is the destination.\n            short_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < short_lookahead_cost:\n                    short_lookahead_cost = distance\n        \n        # Part 3: Long-term lookahead cost, i.e., distance from the candidate back to the start (from Algo 1).\n        long_lookahead_cost = distance_matrix[candidate_node][destination_node]\n\n        # The new score combines the three ideas with weights reflecting their observed effectiveness.\n        score = (w_immediate * immediate_cost) + \\\n                (w_short_lookahead * short_lookahead_cost) + \\\n                (w_long_lookahead * long_lookahead_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.16474,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm enhances the greedy nearest neighbor approach by selecting the next node based on a weighted score that balances immediate and future costs. The score heavily prioritizes the immediate distance from the current node to a candidate (80% weight), while also incorporating a smaller, one-step lookahead cost represented by the distance from that candidate to its own nearest unvisited neighbor (20% weight). This method favors nodes that are not only close now but also offer a promising subsequent move.",
          "thought": "The new algorithm enhances the greedy nearest neighbor approach by evaluating each candidate not only on its immediate distance but also on the distance to its own nearest neighbor among the remaining unvisited nodes, using a weighted score to select the candidate that offers the most promising two-step path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is set to 0.8 to heavily prioritize the immediate neighbor (inspired by Algo 2's success)\n    # but includes a 20% weight for a one-step lookahead cost (a refined version of Algo 1's concept).\n    alpha = 0.8\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future cost, defined as the distance from the candidate to its own nearest neighbor.\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        \n        min_dist_from_candidate = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, the future cost is the distance back to the start.\n            min_dist_from_candidate = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < min_dist_from_candidate:\n                    min_dist_from_candidate = distance\n        \n        # The score balances the immediate move with the quality of the subsequent move.\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * min_dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.20148,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a composite score that considers the immediate travel cost, the candidate's centrality to remaining nodes, and the final return cost. Critically, it employs dynamic weights that shift the heuristic's priority based on tour progress: it starts by emphasizing central nodes to build a good tour structure, then transitions to a more greedy strategy that favors the nearest neighbor as the tour nears completion.",
          "thought": "This algorithm selects the next node using a score that dynamically balances immediate travel cost, the candidate's centrality among remaining nodes, and the final return cost, by adjusting weighting factors based on the tour's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n\n    # Determine the total number of nodes and the current progress of the tour\n    total_nodes = len(distance_matrix)\n    num_unvisited = len(unvisited_nodes)\n    \n    # Progress is a ratio of visited nodes to total nodes, influencing the weights.\n    # It ranges from (approx) 0.0 at the start to 1.0 at the end.\n    progress = 1.0 - (num_unvisited / (total_nodes - 1)) if total_nodes > 1 else 1.0\n\n    # --- Dynamic Weighting Parameters ---\n    # alpha: Weight for immediate cost. Increases as the tour progresses, making the\n    # choice more greedy towards the end. (Ranges from 0.5 to 1.0)\n    alpha = 0.5 + (0.5 * progress)\n\n    # beta: Weight for centrality. Decreases as the tour progresses. Prioritizes\n    # visiting nodes central to the remaining cluster early on. (Ranges from 0.3 to 0.0)\n    beta = 0.3 * (1.0 - progress)\n\n    # gamma: Weight for the final return cost. It takes the remaining portion.\n    gamma = 1.0 - alpha - beta\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Immediate Cost (current -> candidate)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Component 2: Centrality Cost (candidate's avg distance to other unvisited nodes)\n        other_unvisited = unvisited_nodes - {candidate_node}\n        if other_unvisited:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            centrality_cost = sum_dist_to_others / len(other_unvisited)\n        else:\n            # If this is the last node, its centrality cost is zero.\n            centrality_cost = 0\n\n        # Component 3: Final Return Cost (candidate -> destination)\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the dynamically adjusted weights\n        score = (alpha * dist_to_candidate) + (beta * centrality_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    # Fallback for the very last node, though the loop should find it.\n    if next_node is None and unvisited_nodes:\n        return list(unvisited_nodes)[0]\n\n    return next_node",
          "objective": 7.34673,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a composite score for each unvisited candidate, combining three weighted factors: the immediate distance from the current node, a one-step lookahead to the candidate's nearest neighbor, and the distance back to the destination. The selection heavily prioritizes the immediate greedy choice (alpha=0.7), while giving secondary importance to the lookahead cost (beta=0.2) and minimal weight to the return journey (gamma=0.1). The candidate node with the lowest overall score is chosen as the next step in the path.",
          "thought": "This algorithm refines the two-part scoring of the No.2 algorithm by incorporating a third component from the No.1 algorithm, creating a composite score that balances the immediate greedy choice, a one-step lookahead to the next nearest neighbor, and the distance to the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three-part scoring function.\n    # alpha: Prioritizes immediate nearest neighbor (greedy).\n    # beta: Prioritizes a good one-step lookahead (from Algo 2).\n    # gamma: Prioritizes proximity to the destination (from Algo 1).\n    alpha = 0.7\n    beta = 0.2\n    gamma = 0.1\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost (distance from current to candidate).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: One-step lookahead cost (distance from candidate to its own nearest unvisited neighbor).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        if not remaining_nodes:\n            # If candidate is the last unvisited node, this cost is the distance back to the start.\n            one_step_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            one_step_lookahead_cost = min(distance_matrix[candidate_node][other] for other in remaining_nodes)\n            \n        # Part 3: Return journey cost (distance from candidate to destination).\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the three weighted components.\n        score = (alpha * immediate_cost) + (beta * one_step_lookahead_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.37722,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score for each unvisited candidate and choosing the one with the minimum score. Using a fixed `alpha` parameter of 0.7, the scoring function heavily prioritizes the immediate distance from the current node (70% weight) over the future distance from the candidate back to the final destination (30% weight).",
          "thought": "This algorithm implements a weighted greedy heuristic that selects the next node by calculating a score for each candidate that balances the immediate distance from the current node against the candidate's distance to the final destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is a weighting factor. A value of 1.0 makes this equivalent to the standard nearest neighbor.\n    # A value of 0.0 would always choose the unvisited node closest to the destination.\n    # A value of 0.7 prioritizes the nearest neighbor but also considers the return journey.\n    alpha = 0.7\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Distance from the current node to the candidate (immediate cost)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Distance from the candidate to the final destination (future cost)\n        dist_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Weighted score equation to balance immediate and future costs\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node by calculating a weighted score for each unvisited candidate based on the current node, the tour's starting destination, and a distance matrix. The algorithm gives higher priority (60% weight) to the immediate distance from the current node, while also considering the distance from the candidate back to the starting point (40% weight). This approach balances a short-term greedy choice with a long-term strategy for efficiently closing the tour.",
          "thought": "This algorithm modifies the selection score by replacing the one-step lookahead cost with the distance from the candidate node back to the starting point, balancing immediate proximity (60% weight) with progress towards completing the full circuit (40% weight).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node based on a weighted score of the distance from the current node\n    and the distance from the candidate node back to the destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is set to 0.6 to balance the immediate cost (60%) with the cost of\n    # returning to the start from the candidate node (40%).\n    alpha = 0.6\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: \"Future\" cost, redefined as the distance from the candidate back to the starting node.\n        # This encourages choices that move the path closer to the tour's end.\n        dist_to_destination = distance_matrix[candidate_node][destination_node]\n        \n        # The new score balances the immediate move with closing the loop.\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_to_destination)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node by calculating a composite score for each candidate, heavily prioritizing the immediate travel cost (alpha=0.6) for a primarily greedy selection. This greedy choice is then refined by two secondary factors: the candidate's average distance to remaining unvisited nodes and its distance back to the destination, which help avoid selecting isolated nodes far from the main cluster or the end point.",
          "thought": "This algorithm selects the next node by calculating a composite score that balances the immediate travel cost (alpha), the candidate's average distance to all other unvisited nodes (beta), and the final return distance (gamma).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three-part scoring function.\n    # alpha: Prioritizes immediate nearest neighbor (greedy).\n    # beta: Prioritizes candidates that are centrally located to other unvisited nodes (look-ahead).\n    # gamma: Prioritizes candidates that are closer to the final destination (end-game).\n    alpha = 0.6\n    beta = 0.2\n    gamma = 0.2\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost (distance from current to candidate).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future outlook cost (average distance from candidate to all OTHER unvisited nodes).\n        # This penalizes nodes that are \"isolated\" from the remaining cluster of unvisited nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        if not other_unvisited_nodes:\n            # If the candidate is the last unvisited node, this cost is zero.\n            future_outlook_cost = 0.0\n        else:\n            total_future_dist = sum(distance_matrix[candidate_node][other_node] for other_node in other_unvisited_nodes)\n            future_outlook_cost = total_future_dist / len(other_unvisited_nodes)\n            \n        # Part 3: Return journey cost (distance from candidate to destination).\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the three weighted components.\n        score = (alpha * immediate_cost) + (beta * future_outlook_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.72489,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm greedily selects the next node by minimizing a \"detour\" cost, which is calculated as the sum of the distance from the current node to a candidate and the distance from that candidate back to the starting destination. By choosing the candidate with the lowest score, the heuristic strategically balances the immediate cost of reaching a new node with the future cost of returning to the origin.",
          "thought": "This algorithm selects the next node by choosing the candidate which minimizes the sum of two distances: the distance from the current node to the candidate, and the distance from the candidate to the starting destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node based on a score that balances the distance from the current node\n    and the distance to the final destination. This is a variant of the cheapest insertion\n    heuristic applied sequentially, choosing the node that creates the smallest \"detour\".\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # The score is the sum of the distance to the candidate and from the candidate back to the start.\n        # This considers the cost of the \"detour\" through the candidate node.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        score = dist_to_candidate + dist_from_candidate_to_dest\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a composite score that gives the highest priority to the immediate travel cost. The score also incorporates a look-ahead cost, based on the candidate's average distance to its `k` nearest unvisited neighbors, and a dynamic penalty for being far from the destination that grows stronger as the tour progresses.",
          "thought": "This algorithm selects the next node by minimizing a composite score that balances the immediate travel cost, the average distance to the candidate's `k` nearest unvisited neighbors, and a dynamically weighted penalty for the distance to the final destination, which increases as the tour progresses.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node based on a score combining immediate cost,\n    local future cost (average to k-nearest), and a dynamic destination penalty.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # --- Algorithm Parameters ---\n    # k: Number of nearest neighbors to consider for the local future cost.\n    k = 3\n    # Weights for the score components:\n    # alpha: weight for the immediate cost (current -> candidate).\n    # beta: weight for the local future cost (candidate's neighborhood).\n    # gamma: base weight for the destination penalty.\n    alpha = 0.5  # Immediate cost\n    beta = 0.3   # Local cluster cost\n    gamma = 0.2  # Destination proximity penalty\n\n    total_nodes = len(distance_matrix)\n    # Progress factor: increases as more nodes are visited.\n    # Ranges from approx 1/N to (N-1)/N during the tour.\n    progress = (total_nodes - len(unvisited_nodes)) / total_nodes\n\n    for candidate_node in unvisited_nodes:\n        # --- Component 1: Immediate Cost ---\n        # The direct distance from the current node to the candidate.\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # --- Component 2: Local Future Cost ---\n        # Average distance from the candidate to its k-nearest unvisited neighbors.\n        # This gives a sense of how well-connected the candidate is to the remaining cluster.\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        local_future_cost = 0.0\n\n        if not remaining_nodes:\n            # If the candidate is the last node, the future cost is the trip back to the start.\n            local_future_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find distances from the candidate to all other unvisited nodes.\n            dists_from_candidate = sorted([distance_matrix[candidate_node][n] for n in remaining_nodes])\n            \n            # Determine how many neighbors to average (up to k).\n            num_neighbors_to_consider = min(k, len(dists_from_candidate))\n            \n            # Calculate the average distance to the k-nearest neighbors.\n            if num_neighbors_to_consider > 0:\n                local_future_cost = sum(dists_from_candidate[:num_neighbors_to_consider]) / num_neighbors_to_consider\n\n        # --- Component 3: Dynamic Destination Penalty ---\n        # A penalty for moving to a node far from the destination.\n        # The penalty's influence grows as the tour progresses (progress factor).\n        dist_to_destination = distance_matrix[candidate_node][destination_node]\n        destination_penalty = progress * dist_to_destination\n\n        # --- Final Score Calculation ---\n        # Combine the three components using the defined weights.\n        score = (alpha * immediate_cost) + (beta * local_future_cost) + (gamma * destination_penalty)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.27368,
          "other_inf": null
     }
]