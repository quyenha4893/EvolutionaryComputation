[
     {
          "algorithm": "This algorithm implements a greedy Nearest Neighbor heuristic, constructing the tour by iteratively selecting the absolute closest unvisited node from the current location. The selection logic solely prioritizes minimizing the immediate distance to the next node, completely ignoring the final destination node during the construction process.",
          "thought": "The algorithm constructs a tour by starting at an arbitrary node and repeatedly visiting the closest unvisited node until all nodes are visited, finally returning to the start.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    shortest_distance = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        distance = distance_matrix[current_node][candidate_node]\n        if distance < shortest_distance:\n            shortest_distance = distance\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This greedy heuristic algorithm selects the next node by minimizing a score calculated as the distance to a candidate node minus the distance from that candidate back to the tour's origin. This scoring method prioritizes choosing a nearby node that is far from the starting point. The algorithm's strategy is to delay the final long return trip as late as possible in the tour construction.",
          "thought": "This algorithm greedily selects the next node by minimizing a score calculated as the difference between the distance from the current node to a candidate and the distance from that candidate back to the starting destination, thereby favoring nodes that are close by but far from the origin.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a score that prioritizes nodes that are\n    close to the current node but far from the final destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # The score is the difference between the distance to the candidate and the distance from the candidate to the destination.\n        # This heuristic tries to move to a nearby node that is far from the start, pushing the return trip to later.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        score = dist_to_candidate - dist_from_candidate_to_dest\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.07913,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by balancing immediate cost, distance to the destination, and a novel sparseness bonus for outlier nodes. It dynamically prioritizes visiting these outliers early in the tour by applying a high initial weight (`gamma`) to the bonus, which diminishes over time, causing the selection to gradually revert to a traditional greedy-with-foresight approach dominated by the immediate cost (`alpha`) and final destination cost (`beta`).",
          "thought": "This algorithm enhances the \"greedy with foresight\" strategy by introducing a dynamic \"sparseness bonus\" that prioritizes visiting outlier nodes early in the tour, with the bonus's influence diminishing as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    \n    total_nodes = len(distance_matrix)\n    if not unvisited_nodes:\n        return None\n\n    # This factor determines the maximum weight given to the sparseness bonus.\n    max_sparseness_influence = 0.4\n    num_unvisited = len(unvisited_nodes)\n    \n    # The weight for the sparseness factor, 'gamma', is calculated dynamically.\n    # It is highest at the start of the tour and decreases as nodes are visited.\n    if total_nodes > 1:\n        gamma = max_sparseness_influence * (num_unvisited - 1) / (total_nodes - 1)\n    else:\n        gamma = 0\n    \n    # The original greedy ('alpha') and foresight ('beta') weights are scaled\n    # by the remaining influence after the sparseness factor is accounted for.\n    alpha = (1 - gamma) * 0.7\n    beta = (1 - gamma) * 0.3\n\n    for candidate_node in unvisited_nodes:\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        cost_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # A new \"sparseness\" mechanism is introduced. It calculates the average\n        # distance from the candidate to all other unvisited nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        sparseness_score = 0\n        if other_unvisited_nodes:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            sparseness_score = total_dist_to_others / len(other_unvisited_nodes)\n        \n        # The new evaluation equation incorporates the dynamic sparseness bonus.\n        # A bonus is given (score is reduced) for selecting \"sparse\" nodes,\n        # which are likely outliers that would be costly to visit later.\n        score = (alpha * cost_to_candidate) + (beta * cost_from_candidate_to_dest) - (gamma * sparseness_score)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.13502,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node using a weighted scoring system that predominantly follows a greedy approach, assigning an 85% priority to the immediate distance from the current node. The algorithm refines this greedy choice by incorporating two lower-priority lookahead factors: a 10% weight for the distance to the candidate's own nearest neighbor and a 5% weight for the distance back to the final destination. This balanced method aims to avoid poor local choices while maintaining a general direction towards the tour's end.",
          "thought": "This algorithm selects the next node using a three-part weighted score that heavily prioritizes immediate distance (85%), while also considering a short-term one-step lookahead to the next nearest neighbor (10%) and a long-range pull towards the final destination (5%).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three components, prioritizing the greedy choice while adding smarter lookaheads.\n    w_immediate = 0.85         # Inspired by the success of the greedy approach (Algo 3).\n    w_short_lookahead = 0.10   # Inspired by the refined lookahead of Algo 2.\n    w_long_lookahead = 0.05    # Inspired by the destination-aware heuristic of Algo 1.\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate (from Algo 3).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Short-term lookahead cost, i.e., distance from the candidate to its own nearest neighbor (from Algo 2).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        short_lookahead_cost = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, its 'next step' is the destination.\n            short_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < short_lookahead_cost:\n                    short_lookahead_cost = distance\n        \n        # Part 3: Long-term lookahead cost, i.e., distance from the candidate back to the start (from Algo 1).\n        long_lookahead_cost = distance_matrix[candidate_node][destination_node]\n\n        # The new score combines the three ideas with weights reflecting their observed effectiveness.\n        score = (w_immediate * immediate_cost) + \\\n                (w_short_lookahead * short_lookahead_cost) + \\\n                (w_long_lookahead * long_lookahead_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.16474,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm enhances the greedy nearest neighbor approach by selecting the next node based on a weighted score that balances immediate and future costs. The score heavily prioritizes the immediate distance from the current node to a candidate (80% weight), while also incorporating a smaller, one-step lookahead cost represented by the distance from that candidate to its own nearest unvisited neighbor (20% weight). This method favors nodes that are not only close now but also offer a promising subsequent move.",
          "thought": "The new algorithm enhances the greedy nearest neighbor approach by evaluating each candidate not only on its immediate distance but also on the distance to its own nearest neighbor among the remaining unvisited nodes, using a weighted score to select the candidate that offers the most promising two-step path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is set to 0.8 to heavily prioritize the immediate neighbor (inspired by Algo 2's success)\n    # but includes a 20% weight for a one-step lookahead cost (a refined version of Algo 1's concept).\n    alpha = 0.8\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future cost, defined as the distance from the candidate to its own nearest neighbor.\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        \n        min_dist_from_candidate = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, the future cost is the distance back to the start.\n            min_dist_from_candidate = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < min_dist_from_candidate:\n                    min_dist_from_candidate = distance\n        \n        # The score balances the immediate move with the quality of the subsequent move.\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * min_dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.20148,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a score that primarily favors the nearest unvisited neighbor, making it a highly greedy approach. To add foresight, this main cost is augmented with a minor penalty, calculated as a small fraction of the candidate node's distance back to the final destination, which discourages moving to a node that is excessively far from the end of the tour.",
          "thought": "This algorithm selects the next node by minimizing a score that adds a small, scaled penalty based on the candidate's distance to the destination to the primary cost of traveling from the current node, making it a highly greedy heuristic that is slightly moderated by the lookahead cost.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by adding a small penalty for moving away from the destination.\n    This heuristic is mostly greedy, focusing on the immediate next step, but it is\n    moderated by a scaled-down cost of returning to the start, preventing it from\n    choosing a nearby node that is prohibitively far from the destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # A small factor to penalize choices that move far from the destination.\n    # This makes the algorithm more greedy than No.1 but smarter than pure nearest-neighbor.\n    lookahead_penalty_factor = 0.2\n\n    for candidate_node in unvisited_nodes:\n        # The primary cost is the distance to the candidate node (greedy choice).\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # The penalty is a fraction of the distance from the candidate back to the start.\n        penalty_cost = lookahead_penalty_factor * distance_matrix[candidate_node][destination_node]\n        \n        # The score prioritizes the nearest neighbor but adds a small penalty for moving away from the destination.\n        score = cost_to_candidate + penalty_cost\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.25108,
          "other_inf": null
     },
     {
          "algorithm": "This hybrid heuristic algorithm selects the next node using a weighted score that heavily prioritizes the immediate travel cost (80% weight), making it primarily a greedy Nearest Neighbor strategy. To guide the tour towards a more compact shape, it incorporates a minor penalty (20% weight) based on the candidate node's distance back to the original starting point. This approach favors the closest unvisited node but slightly penalizes choices that stray too far from the tour's origin.",
          "thought": "This algorithm creates a hybrid heuristic by calculating a weighted score for each unvisited node, combining the immediate travel cost with a smaller, weighted penalty for the distance back to the destination, thereby balancing the pure greedy choice with a slight global tour compactness consideration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a weighted score that balances the immediate\n    cost (Nearest Neighbor) with a lookahead penalty (distance to destination).\n    This hybrid approach favors the closest node but penalizes choices that\n    move the tour excessively far from its origin.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n    \n    # Alpha is a weighting factor. A small alpha (e.g., 0.2) gives high priority\n    # to the nearest neighbor while still applying a small penalty for moving\n    # far from the destination. (1-alpha) is weight for immediate cost, alpha for lookahead cost.\n    alpha = 0.2\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # Cost of the immediate step: current -> candidate\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Lookahead cost: candidate -> destination\n        cost_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # Calculate the weighted score\n        score = (1 - alpha) * cost_to_candidate + alpha * cost_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a score for each unvisited candidate, which is the ratio of its detour cost to its remoteness factor (the average distance to other unvisited nodes). By minimizing this score, the heuristic prioritizes nodes that are not only on an efficient path back to the destination but are also more geographically isolated from other remaining nodes. This balances immediate path efficiency with the strategic need to visit distant nodes sooner.",
          "thought": "This algorithm enhances the detour-based selection by introducing a remoteness factor, prioritizing nodes that are not only on an efficient path back to the start but are also geographically isolated from other remaining unvisited nodes, calculated as the ratio of the detour cost to the average distance to other unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by calculating a score that is the ratio of the \"detour cost\" \n    to a \"remoteness factor\", effectively balancing the immediate path efficiency with \n    the urgency of visiting isolated nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # Calculate the standard \"detour\" cost as in the original algorithm.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        detour_cost = dist_to_candidate + dist_from_candidate_to_dest\n\n        # Calculate the \"remoteness factor\": the average distance from the candidate\n        # to all *other* unvisited nodes. This quantifies how isolated the candidate is.\n        other_unvisited = [n for n in unvisited_nodes if n != candidate_node]\n        \n        if not other_unvisited:\n            # If this is the last unvisited node, remoteness is not a factor.\n            remoteness_factor = 1.0\n        else:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            remoteness_factor = total_dist_to_others / len(other_unvisited)\n\n        # The new score prioritizes nodes with a low detour cost, but gives preference\n        # to those that are more remote (higher remoteness_factor) by normalizing the detour cost.\n        # A small positive number is added to avoid division by zero if all distances are 0.\n        score = detour_cost / (remoteness_factor + 1e-9)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.33491,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a composite score that considers the immediate travel cost, the candidate's centrality to remaining nodes, and the final return cost. Critically, it employs dynamic weights that shift the heuristic's priority based on tour progress: it starts by emphasizing central nodes to build a good tour structure, then transitions to a more greedy strategy that favors the nearest neighbor as the tour nears completion.",
          "thought": "This algorithm selects the next node using a score that dynamically balances immediate travel cost, the candidate's centrality among remaining nodes, and the final return cost, by adjusting weighting factors based on the tour's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n\n    # Determine the total number of nodes and the current progress of the tour\n    total_nodes = len(distance_matrix)\n    num_unvisited = len(unvisited_nodes)\n    \n    # Progress is a ratio of visited nodes to total nodes, influencing the weights.\n    # It ranges from (approx) 0.0 at the start to 1.0 at the end.\n    progress = 1.0 - (num_unvisited / (total_nodes - 1)) if total_nodes > 1 else 1.0\n\n    # --- Dynamic Weighting Parameters ---\n    # alpha: Weight for immediate cost. Increases as the tour progresses, making the\n    # choice more greedy towards the end. (Ranges from 0.5 to 1.0)\n    alpha = 0.5 + (0.5 * progress)\n\n    # beta: Weight for centrality. Decreases as the tour progresses. Prioritizes\n    # visiting nodes central to the remaining cluster early on. (Ranges from 0.3 to 0.0)\n    beta = 0.3 * (1.0 - progress)\n\n    # gamma: Weight for the final return cost. It takes the remaining portion.\n    gamma = 1.0 - alpha - beta\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Immediate Cost (current -> candidate)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Component 2: Centrality Cost (candidate's avg distance to other unvisited nodes)\n        other_unvisited = unvisited_nodes - {candidate_node}\n        if other_unvisited:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            centrality_cost = sum_dist_to_others / len(other_unvisited)\n        else:\n            # If this is the last node, its centrality cost is zero.\n            centrality_cost = 0\n\n        # Component 3: Final Return Cost (candidate -> destination)\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the dynamically adjusted weights\n        score = (alpha * dist_to_candidate) + (beta * centrality_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    # Fallback for the very last node, though the loop should find it.\n    if next_node is None and unvisited_nodes:\n        return list(unvisited_nodes)[0]\n\n    return next_node",
          "objective": 7.34673,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a composite score for each unvisited candidate, combining three weighted factors: the immediate distance from the current node, a one-step lookahead to the candidate's nearest neighbor, and the distance back to the destination. The selection heavily prioritizes the immediate greedy choice (alpha=0.7), while giving secondary importance to the lookahead cost (beta=0.2) and minimal weight to the return journey (gamma=0.1). The candidate node with the lowest overall score is chosen as the next step in the path.",
          "thought": "This algorithm refines the two-part scoring of the No.2 algorithm by incorporating a third component from the No.1 algorithm, creating a composite score that balances the immediate greedy choice, a one-step lookahead to the next nearest neighbor, and the distance to the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three-part scoring function.\n    # alpha: Prioritizes immediate nearest neighbor (greedy).\n    # beta: Prioritizes a good one-step lookahead (from Algo 2).\n    # gamma: Prioritizes proximity to the destination (from Algo 1).\n    alpha = 0.7\n    beta = 0.2\n    gamma = 0.1\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost (distance from current to candidate).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: One-step lookahead cost (distance from candidate to its own nearest unvisited neighbor).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        if not remaining_nodes:\n            # If candidate is the last unvisited node, this cost is the distance back to the start.\n            one_step_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            one_step_lookahead_cost = min(distance_matrix[candidate_node][other] for other in remaining_nodes)\n            \n        # Part 3: Return journey cost (distance from candidate to destination).\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the three weighted components.\n        score = (alpha * immediate_cost) + (beta * one_step_lookahead_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.37722,
          "other_inf": null
     }
]