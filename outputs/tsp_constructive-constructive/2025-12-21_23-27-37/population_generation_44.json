[
     {
          "algorithm": "This algorithm implements a greedy Nearest Neighbor heuristic, constructing the tour by iteratively selecting the absolute closest unvisited node from the current location. The selection logic solely prioritizes minimizing the immediate distance to the next node, completely ignoring the final destination node during the construction process.",
          "thought": "The algorithm constructs a tour by starting at an arbitrary node and repeatedly visiting the closest unvisited node until all nodes are visited, finally returning to the start.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    shortest_distance = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        distance = distance_matrix[current_node][candidate_node]\n        if distance < shortest_distance:\n            shortest_distance = distance\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by balancing immediate cost, distance to the destination, and a novel sparseness bonus for outlier nodes. It dynamically prioritizes visiting these outliers early in the tour by applying a high initial weight (`gamma`) to the bonus, which diminishes over time, causing the selection to gradually revert to a traditional greedy-with-foresight approach dominated by the immediate cost (`alpha`) and final destination cost (`beta`).",
          "thought": "This algorithm enhances the \"greedy with foresight\" strategy by introducing a dynamic \"sparseness bonus\" that prioritizes visiting outlier nodes early in the tour, with the bonus's influence diminishing as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    \n    total_nodes = len(distance_matrix)\n    if not unvisited_nodes:\n        return None\n\n    # This factor determines the maximum weight given to the sparseness bonus.\n    max_sparseness_influence = 0.4\n    num_unvisited = len(unvisited_nodes)\n    \n    # The weight for the sparseness factor, 'gamma', is calculated dynamically.\n    # It is highest at the start of the tour and decreases as nodes are visited.\n    if total_nodes > 1:\n        gamma = max_sparseness_influence * (num_unvisited - 1) / (total_nodes - 1)\n    else:\n        gamma = 0\n    \n    # The original greedy ('alpha') and foresight ('beta') weights are scaled\n    # by the remaining influence after the sparseness factor is accounted for.\n    alpha = (1 - gamma) * 0.7\n    beta = (1 - gamma) * 0.3\n\n    for candidate_node in unvisited_nodes:\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        cost_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # A new \"sparseness\" mechanism is introduced. It calculates the average\n        # distance from the candidate to all other unvisited nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        sparseness_score = 0\n        if other_unvisited_nodes:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            sparseness_score = total_dist_to_others / len(other_unvisited_nodes)\n        \n        # The new evaluation equation incorporates the dynamic sparseness bonus.\n        # A bonus is given (score is reduced) for selecting \"sparse\" nodes,\n        # which are likely outliers that would be costly to visit later.\n        score = (alpha * cost_to_candidate) + (beta * cost_from_candidate_to_dest) - (gamma * sparseness_score)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.13502,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node using a weighted scoring system that predominantly follows a greedy approach, assigning an 85% priority to the immediate distance from the current node. The algorithm refines this greedy choice by incorporating two lower-priority lookahead factors: a 10% weight for the distance to the candidate's own nearest neighbor and a 5% weight for the distance back to the final destination. This balanced method aims to avoid poor local choices while maintaining a general direction towards the tour's end.",
          "thought": "This algorithm selects the next node using a three-part weighted score that heavily prioritizes immediate distance (85%), while also considering a short-term one-step lookahead to the next nearest neighbor (10%) and a long-range pull towards the final destination (5%).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three components, prioritizing the greedy choice while adding smarter lookaheads.\n    w_immediate = 0.85         # Inspired by the success of the greedy approach (Algo 3).\n    w_short_lookahead = 0.10   # Inspired by the refined lookahead of Algo 2.\n    w_long_lookahead = 0.05    # Inspired by the destination-aware heuristic of Algo 1.\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate (from Algo 3).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Short-term lookahead cost, i.e., distance from the candidate to its own nearest neighbor (from Algo 2).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        short_lookahead_cost = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, its 'next step' is the destination.\n            short_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < short_lookahead_cost:\n                    short_lookahead_cost = distance\n        \n        # Part 3: Long-term lookahead cost, i.e., distance from the candidate back to the start (from Algo 1).\n        long_lookahead_cost = distance_matrix[candidate_node][destination_node]\n\n        # The new score combines the three ideas with weights reflecting their observed effectiveness.\n        score = (w_immediate * immediate_cost) + \\\n                (w_short_lookahead * short_lookahead_cost) + \\\n                (w_long_lookahead * long_lookahead_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.16474,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm enhances the greedy nearest neighbor approach by selecting the next node based on a weighted score that balances immediate and future costs. The score heavily prioritizes the immediate distance from the current node to a candidate (80% weight), while also incorporating a smaller, one-step lookahead cost represented by the distance from that candidate to its own nearest unvisited neighbor (20% weight). This method favors nodes that are not only close now but also offer a promising subsequent move.",
          "thought": "The new algorithm enhances the greedy nearest neighbor approach by evaluating each candidate not only on its immediate distance but also on the distance to its own nearest neighbor among the remaining unvisited nodes, using a weighted score to select the candidate that offers the most promising two-step path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is set to 0.8 to heavily prioritize the immediate neighbor (inspired by Algo 2's success)\n    # but includes a 20% weight for a one-step lookahead cost (a refined version of Algo 1's concept).\n    alpha = 0.8\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future cost, defined as the distance from the candidate to its own nearest neighbor.\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        \n        min_dist_from_candidate = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, the future cost is the distance back to the start.\n            min_dist_from_candidate = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < min_dist_from_candidate:\n                    min_dist_from_candidate = distance\n        \n        # The score balances the immediate move with the quality of the subsequent move.\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * min_dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.20148,
          "other_inf": null
     },
     {
          "algorithm": "This hybrid heuristic algorithm selects the next node using a weighted score that heavily prioritizes the immediate travel cost (80% weight), making it primarily a greedy Nearest Neighbor strategy. To guide the tour towards a more compact shape, it incorporates a minor penalty (20% weight) based on the candidate node's distance back to the original starting point. This approach favors the closest unvisited node but slightly penalizes choices that stray too far from the tour's origin.",
          "thought": "This algorithm creates a hybrid heuristic by calculating a weighted score for each unvisited node, combining the immediate travel cost with a smaller, weighted penalty for the distance back to the destination, thereby balancing the pure greedy choice with a slight global tour compactness consideration.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a weighted score that balances the immediate\n    cost (Nearest Neighbor) with a lookahead penalty (distance to destination).\n    This hybrid approach favors the closest node but penalizes choices that\n    move the tour excessively far from its origin.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n    \n    # Alpha is a weighting factor. A small alpha (e.g., 0.2) gives high priority\n    # to the nearest neighbor while still applying a small penalty for moving\n    # far from the destination. (1-alpha) is weight for immediate cost, alpha for lookahead cost.\n    alpha = 0.2\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # Cost of the immediate step: current -> candidate\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Lookahead cost: candidate -> destination\n        cost_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # Calculate the weighted score\n        score = (1 - alpha) * cost_to_candidate + alpha * cost_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.33284,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a composite score that considers the immediate travel cost, the candidate's centrality to remaining nodes, and the final return cost. Critically, it employs dynamic weights that shift the heuristic's priority based on tour progress: it starts by emphasizing central nodes to build a good tour structure, then transitions to a more greedy strategy that favors the nearest neighbor as the tour nears completion.",
          "thought": "This algorithm selects the next node using a score that dynamically balances immediate travel cost, the candidate's centrality among remaining nodes, and the final return cost, by adjusting weighting factors based on the tour's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n\n    # Determine the total number of nodes and the current progress of the tour\n    total_nodes = len(distance_matrix)\n    num_unvisited = len(unvisited_nodes)\n    \n    # Progress is a ratio of visited nodes to total nodes, influencing the weights.\n    # It ranges from (approx) 0.0 at the start to 1.0 at the end.\n    progress = 1.0 - (num_unvisited / (total_nodes - 1)) if total_nodes > 1 else 1.0\n\n    # --- Dynamic Weighting Parameters ---\n    # alpha: Weight for immediate cost. Increases as the tour progresses, making the\n    # choice more greedy towards the end. (Ranges from 0.5 to 1.0)\n    alpha = 0.5 + (0.5 * progress)\n\n    # beta: Weight for centrality. Decreases as the tour progresses. Prioritizes\n    # visiting nodes central to the remaining cluster early on. (Ranges from 0.3 to 0.0)\n    beta = 0.3 * (1.0 - progress)\n\n    # gamma: Weight for the final return cost. It takes the remaining portion.\n    gamma = 1.0 - alpha - beta\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Immediate Cost (current -> candidate)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Component 2: Centrality Cost (candidate's avg distance to other unvisited nodes)\n        other_unvisited = unvisited_nodes - {candidate_node}\n        if other_unvisited:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            centrality_cost = sum_dist_to_others / len(other_unvisited)\n        else:\n            # If this is the last node, its centrality cost is zero.\n            centrality_cost = 0\n\n        # Component 3: Final Return Cost (candidate -> destination)\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the dynamically adjusted weights\n        score = (alpha * dist_to_candidate) + (beta * centrality_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    # Fallback for the very last node, though the loop should find it.\n    if next_node is None and unvisited_nodes:\n        return list(unvisited_nodes)[0]\n\n    return next_node",
          "objective": 7.34673,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a composite score for each unvisited candidate, combining three weighted factors: the immediate distance from the current node, a one-step lookahead to the candidate's nearest neighbor, and the distance back to the destination. The selection heavily prioritizes the immediate greedy choice (alpha=0.7), while giving secondary importance to the lookahead cost (beta=0.2) and minimal weight to the return journey (gamma=0.1). The candidate node with the lowest overall score is chosen as the next step in the path.",
          "thought": "This algorithm refines the two-part scoring of the No.2 algorithm by incorporating a third component from the No.1 algorithm, creating a composite score that balances the immediate greedy choice, a one-step lookahead to the next nearest neighbor, and the distance to the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three-part scoring function.\n    # alpha: Prioritizes immediate nearest neighbor (greedy).\n    # beta: Prioritizes a good one-step lookahead (from Algo 2).\n    # gamma: Prioritizes proximity to the destination (from Algo 1).\n    alpha = 0.7\n    beta = 0.2\n    gamma = 0.1\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost (distance from current to candidate).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: One-step lookahead cost (distance from candidate to its own nearest unvisited neighbor).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        if not remaining_nodes:\n            # If candidate is the last unvisited node, this cost is the distance back to the start.\n            one_step_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            one_step_lookahead_cost = min(distance_matrix[candidate_node][other] for other in remaining_nodes)\n            \n        # Part 3: Return journey cost (distance from candidate to destination).\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the three weighted components.\n        score = (alpha * immediate_cost) + (beta * one_step_lookahead_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.37722,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by minimizing a weighted score that combines the immediate travel cost with the lookahead cost of returning to the starting node. As implemented, the algorithm assigns a significantly higher weight to the immediate travel cost, creating a predominantly greedy heuristic that is still informed by the overall tour structure. This approach makes a locally-optimal decision that is biased towards short-term gains while not completely ignoring the path back to the origin.",
          "thought": "This heuristic modifies the selection criterion by applying a weighted average that prioritizes the immediate travel cost over the lookahead cost of returning to the destination, making the choice more greedy while still considering the overall tour shape.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by giving more weight to the immediate travel cost\n    compared to the cost of returning to the start. It chooses the candidate\n    that minimizes a weighted sum of the distance from the current node and the\n    distance back to the destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Define weights for the two cost components.\n    # A higher weight for cost_to_candidate makes the algorithm more \"greedy\".\n    weight_immediate = 0.75\n    weight_lookahead = 0.25\n\n    # Evaluate each unvisited node as a potential next step.\n    for candidate_node in unvisited_nodes:\n        # Cost of the immediate step: current -> candidate.\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Lookahead cost: the distance from the candidate back to the tour's starting point.\n        cost_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # The score is a weighted sum of the two costs.\n        score = (weight_immediate * cost_to_candidate) + (weight_lookahead * cost_from_candidate_to_dest)\n        \n        # Choose the candidate with the minimum score.\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.39182,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score for each unvisited candidate and choosing the one with the minimum score. Using a fixed `alpha` parameter of 0.7, the scoring function heavily prioritizes the immediate distance from the current node (70% weight) over the future distance from the candidate back to the final destination (30% weight).",
          "thought": "This algorithm implements a weighted greedy heuristic that selects the next node by calculating a score for each candidate that balances the immediate distance from the current node against the candidate's distance to the final destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is a weighting factor. A value of 1.0 makes this equivalent to the standard nearest neighbor.\n    # A value of 0.0 would always choose the unvisited node closest to the destination.\n    # A value of 0.7 prioritizes the nearest neighbor but also considers the return journey.\n    alpha = 0.7\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Distance from the current node to the candidate (immediate cost)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Distance from the candidate to the final destination (future cost)\n        dist_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Weighted score equation to balance immediate and future costs\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a score that combines the full, unweighted distance of the immediate step with a fractional cost of the return trip from the candidate to the final destination. By using a beta parameter to reduce the weight of the return trip, the algorithm heavily prioritizes the nearest neighbor choice while still penalizing candidate nodes that would create a long final leg of the tour. This approach creates a strong greedy selection with a forward-looking penalty.",
          "thought": "This algorithm enhances Algorithm 2 by calculating a score that combines the full cost of the immediate step (`current -> candidate`) with a reduced, fractional cost of the return trip (`candidate -> destination`), creating a stronger bias towards the nearest neighbor while still penalizing distant detours.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by combining the full immediate travel cost with a\n    fractional penalty for the distance from the candidate back to the destination,\n    strongly favoring the nearest neighbor choice.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # This fraction determines how much the return-trip distance is penalized.\n    # A value of 0.5 creates a stronger greedy bias than a simple weighted average.\n    beta = 0.5\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: The full cost of the immediate travel to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Part 2: The cost of returning from the candidate to the start.\n        dist_to_destination = distance_matrix[candidate_node][destination_node]\n        \n        # The score heavily weights the immediate distance, adding only a fraction\n        # of the return-trip cost as a penalty.\n        score = dist_to_candidate + (beta * dist_to_destination)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.45266,
          "other_inf": null
     }
]