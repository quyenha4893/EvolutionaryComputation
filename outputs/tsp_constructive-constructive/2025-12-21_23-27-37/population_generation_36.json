[
     {
          "algorithm": "This algorithm implements a greedy Nearest Neighbor heuristic, constructing the tour by iteratively selecting the absolute closest unvisited node from the current location. The selection logic solely prioritizes minimizing the immediate distance to the next node, completely ignoring the final destination node during the construction process.",
          "thought": "The algorithm constructs a tour by starting at an arbitrary node and repeatedly visiting the closest unvisited node until all nodes are visited, finally returning to the start.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    shortest_distance = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        distance = distance_matrix[current_node][candidate_node]\n        if distance < shortest_distance:\n            shortest_distance = distance\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by balancing immediate cost, distance to the destination, and a novel sparseness bonus for outlier nodes. It dynamically prioritizes visiting these outliers early in the tour by applying a high initial weight (`gamma`) to the bonus, which diminishes over time, causing the selection to gradually revert to a traditional greedy-with-foresight approach dominated by the immediate cost (`alpha`) and final destination cost (`beta`).",
          "thought": "This algorithm enhances the \"greedy with foresight\" strategy by introducing a dynamic \"sparseness bonus\" that prioritizes visiting outlier nodes early in the tour, with the bonus's influence diminishing as the number of unvisited nodes decreases.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n    \n    total_nodes = len(distance_matrix)\n    if not unvisited_nodes:\n        return None\n\n    # This factor determines the maximum weight given to the sparseness bonus.\n    max_sparseness_influence = 0.4\n    num_unvisited = len(unvisited_nodes)\n    \n    # The weight for the sparseness factor, 'gamma', is calculated dynamically.\n    # It is highest at the start of the tour and decreases as nodes are visited.\n    if total_nodes > 1:\n        gamma = max_sparseness_influence * (num_unvisited - 1) / (total_nodes - 1)\n    else:\n        gamma = 0\n    \n    # The original greedy ('alpha') and foresight ('beta') weights are scaled\n    # by the remaining influence after the sparseness factor is accounted for.\n    alpha = (1 - gamma) * 0.7\n    beta = (1 - gamma) * 0.3\n\n    for candidate_node in unvisited_nodes:\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        cost_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # A new \"sparseness\" mechanism is introduced. It calculates the average\n        # distance from the candidate to all other unvisited nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        sparseness_score = 0\n        if other_unvisited_nodes:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            sparseness_score = total_dist_to_others / len(other_unvisited_nodes)\n        \n        # The new evaluation equation incorporates the dynamic sparseness bonus.\n        # A bonus is given (score is reduced) for selecting \"sparse\" nodes,\n        # which are likely outliers that would be costly to visit later.\n        score = (alpha * cost_to_candidate) + (beta * cost_from_candidate_to_dest) - (gamma * sparseness_score)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.13502,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node using a weighted scoring system that predominantly follows a greedy approach, assigning an 85% priority to the immediate distance from the current node. The algorithm refines this greedy choice by incorporating two lower-priority lookahead factors: a 10% weight for the distance to the candidate's own nearest neighbor and a 5% weight for the distance back to the final destination. This balanced method aims to avoid poor local choices while maintaining a general direction towards the tour's end.",
          "thought": "This algorithm selects the next node using a three-part weighted score that heavily prioritizes immediate distance (85%), while also considering a short-term one-step lookahead to the next nearest neighbor (10%) and a long-range pull towards the final destination (5%).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three components, prioritizing the greedy choice while adding smarter lookaheads.\n    w_immediate = 0.85         # Inspired by the success of the greedy approach (Algo 3).\n    w_short_lookahead = 0.10   # Inspired by the refined lookahead of Algo 2.\n    w_long_lookahead = 0.05    # Inspired by the destination-aware heuristic of Algo 1.\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate (from Algo 3).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Short-term lookahead cost, i.e., distance from the candidate to its own nearest neighbor (from Algo 2).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        short_lookahead_cost = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, its 'next step' is the destination.\n            short_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < short_lookahead_cost:\n                    short_lookahead_cost = distance\n        \n        # Part 3: Long-term lookahead cost, i.e., distance from the candidate back to the start (from Algo 1).\n        long_lookahead_cost = distance_matrix[candidate_node][destination_node]\n\n        # The new score combines the three ideas with weights reflecting their observed effectiveness.\n        score = (w_immediate * immediate_cost) + \\\n                (w_short_lookahead * short_lookahead_cost) + \\\n                (w_long_lookahead * long_lookahead_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.16474,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm enhances the greedy nearest neighbor approach by selecting the next node based on a weighted score that balances immediate and future costs. The score heavily prioritizes the immediate distance from the current node to a candidate (80% weight), while also incorporating a smaller, one-step lookahead cost represented by the distance from that candidate to its own nearest unvisited neighbor (20% weight). This method favors nodes that are not only close now but also offer a promising subsequent move.",
          "thought": "The new algorithm enhances the greedy nearest neighbor approach by evaluating each candidate not only on its immediate distance but also on the distance to its own nearest neighbor among the remaining unvisited nodes, using a weighted score to select the candidate that offers the most promising two-step path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is set to 0.8 to heavily prioritize the immediate neighbor (inspired by Algo 2's success)\n    # but includes a 20% weight for a one-step lookahead cost (a refined version of Algo 1's concept).\n    alpha = 0.8\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future cost, defined as the distance from the candidate to its own nearest neighbor.\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        \n        min_dist_from_candidate = float('inf')\n        if not remaining_nodes:\n            # If the candidate is the last unvisited node, the future cost is the distance back to the start.\n            min_dist_from_candidate = distance_matrix[candidate_node][destination_node]\n        else:\n            # Find the candidate's nearest neighbor from the rest of the unvisited nodes.\n            for next_step_node in remaining_nodes:\n                distance = distance_matrix[candidate_node][next_step_node]\n                if distance < min_dist_from_candidate:\n                    min_dist_from_candidate = distance\n        \n        # The score balances the immediate move with the quality of the subsequent move.\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * min_dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.20148,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a composite score that considers the immediate travel cost, the candidate's centrality to remaining nodes, and the final return cost. Critically, it employs dynamic weights that shift the heuristic's priority based on tour progress: it starts by emphasizing central nodes to build a good tour structure, then transitions to a more greedy strategy that favors the nearest neighbor as the tour nears completion.",
          "thought": "This algorithm selects the next node using a score that dynamically balances immediate travel cost, the candidate's centrality among remaining nodes, and the final return cost, by adjusting weighting factors based on the tour's progress.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if not unvisited_nodes:\n        return None\n\n    next_node = None\n    best_score = float('inf')\n\n    # Determine the total number of nodes and the current progress of the tour\n    total_nodes = len(distance_matrix)\n    num_unvisited = len(unvisited_nodes)\n    \n    # Progress is a ratio of visited nodes to total nodes, influencing the weights.\n    # It ranges from (approx) 0.0 at the start to 1.0 at the end.\n    progress = 1.0 - (num_unvisited / (total_nodes - 1)) if total_nodes > 1 else 1.0\n\n    # --- Dynamic Weighting Parameters ---\n    # alpha: Weight for immediate cost. Increases as the tour progresses, making the\n    # choice more greedy towards the end. (Ranges from 0.5 to 1.0)\n    alpha = 0.5 + (0.5 * progress)\n\n    # beta: Weight for centrality. Decreases as the tour progresses. Prioritizes\n    # visiting nodes central to the remaining cluster early on. (Ranges from 0.3 to 0.0)\n    beta = 0.3 * (1.0 - progress)\n\n    # gamma: Weight for the final return cost. It takes the remaining portion.\n    gamma = 1.0 - alpha - beta\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Immediate Cost (current -> candidate)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Component 2: Centrality Cost (candidate's avg distance to other unvisited nodes)\n        other_unvisited = unvisited_nodes - {candidate_node}\n        if other_unvisited:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            centrality_cost = sum_dist_to_others / len(other_unvisited)\n        else:\n            # If this is the last node, its centrality cost is zero.\n            centrality_cost = 0\n\n        # Component 3: Final Return Cost (candidate -> destination)\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the dynamically adjusted weights\n        score = (alpha * dist_to_candidate) + (beta * centrality_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    # Fallback for the very last node, though the loop should find it.\n    if next_node is None and unvisited_nodes:\n        return list(unvisited_nodes)[0]\n\n    return next_node",
          "objective": 7.34673,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a composite score for each unvisited candidate, combining three weighted factors: the immediate distance from the current node, a one-step lookahead to the candidate's nearest neighbor, and the distance back to the destination. The selection heavily prioritizes the immediate greedy choice (alpha=0.7), while giving secondary importance to the lookahead cost (beta=0.2) and minimal weight to the return journey (gamma=0.1). The candidate node with the lowest overall score is chosen as the next step in the path.",
          "thought": "This algorithm refines the two-part scoring of the No.2 algorithm by incorporating a third component from the No.1 algorithm, creating a composite score that balances the immediate greedy choice, a one-step lookahead to the next nearest neighbor, and the distance to the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three-part scoring function.\n    # alpha: Prioritizes immediate nearest neighbor (greedy).\n    # beta: Prioritizes a good one-step lookahead (from Algo 2).\n    # gamma: Prioritizes proximity to the destination (from Algo 1).\n    alpha = 0.7\n    beta = 0.2\n    gamma = 0.1\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost (distance from current to candidate).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: One-step lookahead cost (distance from candidate to its own nearest unvisited neighbor).\n        remaining_nodes = unvisited_nodes - {candidate_node}\n        if not remaining_nodes:\n            # If candidate is the last unvisited node, this cost is the distance back to the start.\n            one_step_lookahead_cost = distance_matrix[candidate_node][destination_node]\n        else:\n            one_step_lookahead_cost = min(distance_matrix[candidate_node][other] for other in remaining_nodes)\n            \n        # Part 3: Return journey cost (distance from candidate to destination).\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the three weighted components.\n        score = (alpha * immediate_cost) + (beta * one_step_lookahead_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.37722,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score for each unvisited candidate and choosing the one with the minimum score. Using a fixed `alpha` parameter of 0.7, the scoring function heavily prioritizes the immediate distance from the current node (70% weight) over the future distance from the candidate back to the final destination (30% weight).",
          "thought": "This algorithm implements a weighted greedy heuristic that selects the next node by calculating a score for each candidate that balances the immediate distance from the current node against the candidate's distance to the final destination node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is a weighting factor. A value of 1.0 makes this equivalent to the standard nearest neighbor.\n    # A value of 0.0 would always choose the unvisited node closest to the destination.\n    # A value of 0.7 prioritizes the nearest neighbor but also considers the return journey.\n    alpha = 0.7\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Distance from the current node to the candidate (immediate cost)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Distance from the candidate to the final destination (future cost)\n        dist_from_candidate = distance_matrix[candidate_node][destination_node]\n\n        # Weighted score equation to balance immediate and future costs\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_from_candidate)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by computing a multiplicative score for each unvisited candidate, calculated as the product of the immediate travel cost and the distance to the final destination. By minimizing this score, the algorithm prioritizes a balanced choice that is strategically close to both the current node and the end goal, rather than just the nearest neighbor. This approach avoids selecting nodes that are close now but lead to a much longer path later.",
          "thought": "This algorithm selects the next node by computing a multiplicative score from the immediate travel cost and the cost to the destination, which synergistically prioritizes candidates that are close to both the current node and the final destination.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate\n        cost_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Estimated cost from the candidate to the final destination\n        cost_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # A new multiplicative scoring equation is used to evaluate candidates.\n        # This approach finds a balance by favoring nodes that minimize the product\n        # of the two cost components, effectively seeking a point that is\n        # reasonably close to both the current node and the final destination.\n        score = cost_to_candidate * cost_from_candidate_to_dest\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node by calculating a weighted score for each unvisited candidate based on the current node, the tour's starting destination, and a distance matrix. The algorithm gives higher priority (60% weight) to the immediate distance from the current node, while also considering the distance from the candidate back to the starting point (40% weight). This approach balances a short-term greedy choice with a long-term strategy for efficiently closing the tour.",
          "thought": "This algorithm modifies the selection score by replacing the one-step lookahead cost with the distance from the candidate node back to the starting point, balancing immediate proximity (60% weight) with progress towards completing the full circuit (40% weight).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node based on a weighted score of the distance from the current node\n    and the distance from the candidate node back to the destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Alpha is set to 0.6 to balance the immediate cost (60%) with the cost of\n    # returning to the start from the candidate node (40%).\n    alpha = 0.6\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Part 2: \"Future\" cost, redefined as the distance from the candidate back to the starting node.\n        # This encourages choices that move the path closer to the tour's end.\n        dist_to_destination = distance_matrix[candidate_node][destination_node]\n        \n        # The new score balances the immediate move with closing the loop.\n        score = (alpha * dist_to_candidate) + ((1 - alpha) * dist_to_destination)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic selects the next node by calculating a composite score for each candidate, heavily prioritizing the immediate travel cost (alpha=0.6) for a primarily greedy selection. This greedy choice is then refined by two secondary factors: the candidate's average distance to remaining unvisited nodes and its distance back to the destination, which help avoid selecting isolated nodes far from the main cluster or the end point.",
          "thought": "This algorithm selects the next node by calculating a composite score that balances the immediate travel cost (alpha), the candidate's average distance to all other unvisited nodes (beta), and the final return distance (gamma).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    if not unvisited_nodes:\n        return None\n\n    # Weights for the three-part scoring function.\n    # alpha: Prioritizes immediate nearest neighbor (greedy).\n    # beta: Prioritizes candidates that are centrally located to other unvisited nodes (look-ahead).\n    # gamma: Prioritizes candidates that are closer to the final destination (end-game).\n    alpha = 0.6\n    beta = 0.2\n    gamma = 0.2\n\n    for candidate_node in unvisited_nodes:\n        # Part 1: Immediate cost (distance from current to candidate).\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Part 2: Future outlook cost (average distance from candidate to all OTHER unvisited nodes).\n        # This penalizes nodes that are \"isolated\" from the remaining cluster of unvisited nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        if not other_unvisited_nodes:\n            # If the candidate is the last unvisited node, this cost is zero.\n            future_outlook_cost = 0.0\n        else:\n            total_future_dist = sum(distance_matrix[candidate_node][other_node] for other_node in other_unvisited_nodes)\n            future_outlook_cost = total_future_dist / len(other_unvisited_nodes)\n            \n        # Part 3: Return journey cost (distance from candidate to destination).\n        return_cost = distance_matrix[candidate_node][destination_node]\n\n        # Composite score using the three weighted components.\n        score = (alpha * immediate_cost) + (beta * future_outlook_cost) + (gamma * return_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.72489,
          "other_inf": null
     }
]