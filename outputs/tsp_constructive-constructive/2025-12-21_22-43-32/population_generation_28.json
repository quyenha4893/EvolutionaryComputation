[
     {
          "algorithm": "This algorithm refines the initial design idea by selecting the next node that minimizes a specific score, calculated as a ratio. The score prioritizes visiting closer nodes (greedy distance in the numerator) but strongly favors those that are also remote from both the final destination and the remaining cluster of unvisited nodes (a combined \"look-ahead\" factor in the denominator). By minimizing this ratio, the heuristic aims to efficiently visit \"outlier\" nodes that are conveniently nearby, addressing them early in the path construction.",
          "thought": "This algorithm selects the next node by minimizing a score that balances the greedy choice of a nearby node against a look-ahead factor combining the node's distance to the final destination and its average distance to all other unvisited nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a score that balances the greedy distance\n    with a look-ahead factor based on remoteness from both the destination and\n    the cluster of other unvisited nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Greedy distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Component 2: Look-ahead based on distance to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Component 3 (Novel Mechanism): Look-ahead based on the candidate's average\n        # distance to all other unvisited nodes (its \"remoteness\").\n        # This helps prioritize visiting \"outlier\" nodes earlier.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        remoteness_factor = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # New Equation: The score is the ratio of the greedy cost to a composite\n        # look-ahead factor. This factor is a sum of the distance to the destination\n        # and the remoteness factor, encouraging visits to nodes that are far\n        # from the end point and also far from the remaining group of nodes.\n        look_ahead_factor = dist_from_candidate_to_dest + remoteness_factor\n        \n        # A small epsilon is added to avoid division by zero.\n        score = dist_to_candidate / (look_ahead_factor + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.5081,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a score calculated as the ratio of the distance from the current node over the distance to the final destination. This strategy gives high priority to nodes that are close to the current location but far from the final destination. By doing so, the algorithm aims to visit distant nodes early in the tour before moving towards nodes closer to the end point.",
          "thought": "This heuristic algorithm selects the next node by minimizing a ratio that prioritizes nodes closer to the current location over those nearer to the final destination, aiming to visit farther nodes earlier in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing the ratio of the distance from the current node\n    to the distance to the final destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is a ratio of the two distances. This prioritizes visiting\n        # nodes that are close to the current node but relatively far from the\n        # destination, effectively pushing the traversal of distant nodes earlier.\n        # A small epsilon is added to avoid division by zero.\n        score = dist_to_candidate / (dist_from_candidate_to_dest + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a hybrid score that is a weighted sum of the simple nearest-neighbor distance and a strategic ratio score (distance to candidate / distance from candidate to destination). By assigning a significantly higher weight to the ratio score via a low `alpha` value, the algorithm prioritizes a globally-aware strategy that considers the final destination. The less-weighted nearest-neighbor distance serves to locally refine this choice, preventing otherwise inefficient jumps.",
          "thought": "My new algorithm selects the next node by calculating a hybrid score that is a weighted sum of the pure nearest-neighbor distance and the superior ratio-based score, primarily relying on the ratio for its strategic advantage while using the nearest-neighbor component to temper the choice and avoid locally inefficient long-distance jumps.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a hybrid score that is a weighted sum of the\n    Nearest Neighbor distance (from Algorithm 2) and the Ratio heuristic (from Algorithm 3).\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # This weighting factor, alpha, balances the two heuristics.\n    # A low alpha gives more weight to the successful Ratio heuristic,\n    # while a high alpha would make it behave more like Nearest Neighbor.\n    alpha = 0.15\n\n    for candidate_node in unvisited_nodes:\n        # Distance from the current node to the candidate (greedy component)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Distance from the candidate to the final destination (look-ahead component)\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Score component from Nearest Neighbor heuristic (Algorithm 2)\n        nn_score = dist_to_candidate\n\n        # Score component from Ratio heuristic (Algorithm 3)\n        # A small epsilon is added to avoid division by zero.\n        ratio_score = dist_to_candidate / (dist_from_candidate_to_dest + 1e-9)\n\n        # The final score is a weighted combination of the two successful strategies.\n        # This leverages the global path-finding strength of the ratio heuristic\n        # while using the simple NN score to refine the local choice.\n        score = alpha * nn_score + (1 - alpha) * ratio_score\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.66854,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm implements a greedy \"Nearest Neighbor\" heuristic to iteratively construct a tour. At each step, it exclusively prioritizes the distance from the `current_node` to select the absolute closest node from the set of unvisited nodes. The final `destination_node` is passed as a parameter but is completely ignored during this selection process.",
          "thought": "The algorithm greedily constructs a tour by iteratively selecting the closest unvisited node to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a strategic score that balances a greedy choice (distance from current node) with a look-ahead penalty (average distance to other unvisited nodes). This score is structured as a ratio that further prioritizes tackling the most distant parts of the tour early by favoring candidate nodes that are far from the final destination.",
          "thought": "This algorithm selects the next node by minimizing a ratio where the numerator is a weighted sum of the distance to the candidate and the candidate's average distance to other unvisited nodes (inspired by algorithm 1), and the denominator is the distance from the candidate to the final destination (inspired by algorithm 2).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a score that combines ideas from\n    both previous algorithms. The score is a ratio: the numerator is a\n    penalized distance (like algorithm 1) and the denominator is the distance\n    to the destination (like algorithm 2).\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Alpha is a weighting factor for the penalty, balancing the greedy choice\n    # with the strategic goal of staying close to the unvisited cluster.\n    alpha = 0.15\n\n    for candidate_node in unvisited_nodes:\n        # Numerator part 1: Distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Numerator part 2: Penalty based on candidate's distance to other unvisited nodes.\n        other_unvisited = unvisited_nodes - {candidate_node}\n        penalty = 0\n        if other_unvisited:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            penalty = total_dist_to_others / len(other_unvisited)\n        \n        # The numerator combines the greedy choice with the strategic penalty.\n        numerator = dist_to_candidate + alpha * penalty\n\n        # Denominator: Distance from the candidate to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score prioritizes nodes that are strategically attractive (low numerator)\n        # and far from the end point (high denominator), effectively tackling\n        # challenging parts of the tour early.\n        # A small epsilon avoids division by zero.\n        score = numerator / (dist_from_candidate_to_dest + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.28837,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a score that gives high priority to nodes far from the final destination, aiming to handle distant points early. This primary objective is refined by a composite cost that balances the immediate travel distance with a \"cohesion factor\"\u2014the candidate's average distance to other unvisited nodes\u2014to prevent isolating points that would be costly to visit later.",
          "thought": "This algorithm enhances the original selection logic by adding a 'cohesion' factor, which calculates a candidate node's average distance to all other unvisited nodes, thereby balancing the preference for distant nodes with the need to stay close to the cluster of remaining points.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a composite score that balances immediate\n    travel cost, cohesion with other unvisited nodes, and distance to the destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n    \n    # Weighting factor to control the influence of the cohesion cost.\n    # A higher value prioritizes keeping the path tight and central.\n    cohesion_factor = 0.5\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # --- New Mechanism: Cohesion Calculation ---\n        # This calculates the average distance from the candidate to all other unvisited\n        # nodes, acting as a penalty for nodes that are isolated from the main group.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        avg_dist_to_others = 0\n        if other_unvisited_nodes:\n            sum_of_dists_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            avg_dist_to_others = sum_of_dists_to_others / len(other_unvisited_nodes)\n            \n        # --- New Equation: Composite Score ---\n        # The numerator is a weighted sum of the direct travel cost and the \"cohesion cost\".\n        # This new term encourages the selection of nodes that are \"central\" to the\n        # remaining unvisited nodes, preventing long detours later in the tour.\n        combined_cost = dist_to_candidate + cohesion_factor * avg_dist_to_others\n\n        # The final score is a ratio of this new combined cost over the distance\n        # to the destination, preserving the original algorithm's intent to\n        # visit far-away nodes earlier.\n        score = combined_cost / (dist_from_candidate_to_dest + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.42126,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm greedily selects the next node by minimizing a composite score for each unvisited candidate. The score is a weighted sum that strongly prioritizes immediate proximity to the current node (70% weight) over the distance to the final destination (30% weight). This balances a short-term nearest-neighbor choice with the long-term goal of efficiently completing the tour.",
          "thought": "This algorithm selects the next node by minimizing a weighted sum of the distance from the current node and the distance to the final destination, balancing the trade-off between immediate proximity and progress towards the end point.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a weighted sum of the distance from the\n    current node and the distance to the final destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n    \n    # Weights to balance the two distance components.\n    # alpha prioritizes nearness to the current node.\n    # beta prioritizes nearness to the final destination.\n    alpha = 0.7 \n    beta = 0.3\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is a weighted sum of the two distances. This provides a\n        # tunable balance between selecting a node that is close (controlled by alpha)\n        # and selecting a node that is on the path towards the destination (controlled by beta).\n        score = (alpha * dist_to_candidate) + (beta * dist_from_candidate_to_dest)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.43323,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic modifies the Nearest Neighbor strategy by choosing the next node based on a composite score rather than just distance. The score is primarily determined by the distance from the current node, but a `beta`-weighted penalty is added for candidates that are, on average, far from the remaining unvisited nodes. This approach balances the greedy choice of picking the closest node with the strategic goal of avoiding early moves to isolated points.",
          "thought": "This algorithm enhances the Nearest Neighbor strategy by selecting the closest node while applying a small penalty based on that node's average distance to all other remaining unvisited nodes, thereby balancing the greedy choice with the strategic goal of staying central to the future path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by finding the nearest neighbor, but penalizes candidates\n    that are far from the cluster of other remaining unvisited nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Beta is a weighting factor for the penalty. A small value ensures we\n    # prioritize the nearest neighbor aspect but still consider the penalty.\n    beta = 0.25\n\n    for candidate_node in unvisited_nodes:\n        # Primary metric: distance from the current node to the candidate\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Penalty metric: average distance from the candidate to all *other* unvisited nodes.\n        # This discourages moving to a node that is isolated from the rest.\n        other_unvisited = unvisited_nodes - {candidate_node}\n        penalty = 0\n        if other_unvisited:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            penalty = total_dist_to_others / len(other_unvisited)\n\n        # The score prioritizes the nearest neighbor but is regularized by the penalty.\n        score = dist_to_candidate + beta * penalty\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.44537,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a score as the product of two key distances: the distance from the current node and the distance to the final destination. By choosing the node with the minimum score, the algorithm gives high priority to candidates that are exceptionally close to either the current position or the tour's end point. This multiplicative approach balances a greedy choice with a strategic move towards completing the tour efficiently.",
          "thought": "This heuristic algorithm selects the next node by calculating a score as the product of the distance from the current node and the distance to the final destination, choosing the node with the minimum score to balance immediate and future costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a multiplicative heuristic that balances the distance\n    from the current node and the distance to the final destination node.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is the product of the two distances. This is a different way\n        # to balance the greedy choice (short distance now) against the\n        # strategic choice (not moving too far from the end point).\n        # A small value for either distance will heavily reduce the score.\n        score = dist_to_candidate * dist_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score that balances the immediate travel cost from the current node against the future cost of returning to the final destination. The key `alpha` parameter, set to 0.6, controls this balance by giving higher priority to minimizing the immediate travel distance while still factoring in the distance to the final goal. The node with the lowest combined score is chosen as the next step in the path.",
          "thought": "This algorithm selects the next node by balancing the immediate travel cost from the current node with the future cost of returning to the final destination, using a weighted score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a weighted heuristic that considers both the distance\n    from the current node and the distance to the final destination node.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Alpha is a weighting factor.\n    # alpha = 1.0 behaves like the standard Nearest Neighbor.\n    # alpha = 0.0 would only focus on picking the node closest to the destination.\n    # A value between 0 and 1 balances these two desires.\n    alpha = 0.6\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is a weighted sum of the two distances. This balances the\n        # greedy choice (short distance now) with a more strategic choice\n        # (not moving too far away from the end point).\n        score = alpha * dist_to_candidate + (1 - alpha) * dist_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     }
]