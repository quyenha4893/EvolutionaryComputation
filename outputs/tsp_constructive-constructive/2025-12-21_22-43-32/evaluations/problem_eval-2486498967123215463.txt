import math

def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    """
    Selects the next node using a score that dynamically weights remoteness against
    destination proximity and penalizes interference with the likely return path.
    """
    total_num_nodes = len(distance_matrix)
    
    # If only one unvisited node remains, it must be the next one.
    if len(unvisited_nodes) == 1:
        return list(unvisited_nodes)[0]

    next_node = None
    best_score = float('inf')

    for candidate_node in unvisited_nodes:
        # Component 1: Greedy cost from the current node.
        dist_to_candidate = distance_matrix[current_node][candidate_node]

        # Define the set of other nodes that would remain if this candidate is chosen.
        other_unvisited_nodes = unvisited_nodes - {candidate_node}

        # Component 2: Dynamically Weighted Look-Ahead.
        # This factor balances visiting remote nodes with heading towards the destination.
        
        # 2a. Remoteness factor: average distance to other unvisited nodes.
        remoteness_factor = 0.0
        if other_unvisited_nodes:
            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)
            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)

        # 2b. Proximity to destination.
        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]
        
        # 2c. Dynamic weight 'alpha' shifts focus as the tour progresses.
        # Early in the tour (high alpha), remoteness is prioritized.
        # Late in the tour (low alpha), destination proximity is prioritized.
        alpha = len(unvisited_nodes) / total_num_nodes
        
        dynamic_look_ahead = (alpha * remoteness_factor) + ((1 - alpha) * dist_from_candidate_to_dest)

        # Component 3 (Novel Mechanism): Return Path Interference Penalty.
        # This penalizes a candidate if it is positioned poorly relative to the
        # most likely final segment of the tour.
        interference_penalty = 0.0
        if other_unvisited_nodes:
            # Find the unvisited node (other than the candidate) that is closest to the destination.
            # This is our "probable penultimate" node.
            penultimate_contender = min(
                other_unvisited_nodes,
                key=lambda node: distance_matrix[node][destination_node]
            )
            
            # The penalty is the extra distance incurred by detouring from the candidate
            # to the destination via this probable penultimate node.
            penalty_triangle_sides = (distance_matrix[candidate_node][penultimate_contender] + 
                                      distance_matrix[penultimate_contender][destination_node])
            interference_penalty = penalty_triangle_sides - dist_from_candidate_to_dest
        
        # New Equation: The score is a ratio of total "costs" to the "benefit" of the look-ahead.
        # Costs include the greedy distance plus the path interference penalty.
        # The benefit is the dynamically weighted look-ahead score.
        total_cost_factor = dist_to_candidate + interference_penalty
        
        score = total_cost_factor / (dynamic_look_ahead + 1e-9)

        if score < best_score:
            best_score = score
            next_node = candidate_node
            
    # Fallback in case no node is selected (should not happen if unvisited_nodes is not empty).
    if next_node is None and unvisited_nodes:
        return list(unvisited_nodes)[0]

    return next_node
