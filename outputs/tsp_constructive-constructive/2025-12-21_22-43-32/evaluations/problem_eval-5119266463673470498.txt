def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):
    best_next_node = None
    min_combined_distance = float('inf')
    
    # A weighting factor to balance the two distance components. 
    # alpha = 1.0 makes it a pure "Nearest Neighbor"
    # alpha = 0.0 makes it "go to the node closest to the destination"
    # alpha = 0.5 gives equal weight to both considerations.
    alpha = 0.5 

    for node in unvisited_nodes:
        # Distance from the current node to the potential next node
        dist_to_next = distance_matrix[current_node][node]
        
        # Distance from the potential next node to the final destination (start node)
        dist_from_next_to_dest = distance_matrix[node][destination_node]
        
        # Calculate a weighted score. The goal is to find a node that is
        # not only close to the current one but also helps in steering the 
        # path back towards the starting point.
        combined_distance = alpha * dist_to_next + (1 - alpha) * dist_from_next_to_dest
        
        if combined_distance < min_combined_distance:
            min_combined_distance = combined_distance
            best_next_node = node
            
    # In case all unvisited nodes are the same as current_node (a rare edge case)
    # or if unvisited_nodes is empty, this might return None.
    # A robust implementation might add a fallback, but for this problem, we assume
    # unvisited_nodes is a non-empty set of distinct nodes.
    if best_next_node is None and unvisited_nodes:
        best_next_node = list(unvisited_nodes)[0]

    return next_node
