[
     {
          "algorithm": "This algorithm implements a greedy \"Nearest Neighbor\" heuristic to iteratively construct a tour. At each step, it exclusively prioritizes the distance from the `current_node` to select the absolute closest node from the set of unvisited nodes. The final `destination_node` is passed as a parameter but is completely ignored during this selection process.",
          "thought": "The algorithm greedily constructs a tour by iteratively selecting the closest unvisited node to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score that balances the immediate travel cost from the current node against the future cost of returning to the final destination. The key `alpha` parameter, set to 0.6, controls this balance by giving higher priority to minimizing the immediate travel distance while still factoring in the distance to the final goal. The node with the lowest combined score is chosen as the next step in the path.",
          "thought": "This algorithm selects the next node by balancing the immediate travel cost from the current node with the future cost of returning to the final destination, using a weighted score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a weighted heuristic that considers both the distance\n    from the current node and the distance to the final destination node.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Alpha is a weighting factor.\n    # alpha = 1.0 behaves like the standard Nearest Neighbor.\n    # alpha = 0.0 would only focus on picking the node closest to the destination.\n    # A value between 0 and 1 balances these two desires.\n    alpha = 0.6\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is a weighted sum of the two distances. This balances the\n        # greedy choice (short distance now) with a more strategic choice\n        # (not moving too far away from the end point).\n        score = alpha * dist_to_candidate + (1 - alpha) * dist_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a multiplicative score that combines the immediate travel cost with a penalty representing the candidate's total distance to all other unvisited nodes. By multiplying these factors, the heuristic aggressively penalizes nodes that are either far from the current position or isolated from the remaining cluster of points. This dual-criteria approach prioritizes creating a compact partial tour, aiming to avoid costly detours to isolated nodes later.",
          "thought": "This heuristic algorithm selects the next node by calculating a multiplicative score from two factors: the immediate travel cost and the candidate's total distance to all other unvisited nodes, aggressively penalizing choices that are both far and isolated.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Factor 1: The immediate cost to travel to the candidate node.\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Factor 2: An \"outlier\" penalty, measured as the sum of distances\n        # from the candidate to all OTHER unvisited nodes.\n        other_unvisited = unvisited_nodes - {candidate_node}\n        outlier_penalty = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n        \n        # The multiplicative score heavily penalizes nodes that are poor on either factor.\n        # A small constant is added to the penalty to ensure that the immediate cost\n        # is still a factor even if a node is co-located with all others (penalty=0).\n        score = immediate_cost * (outlier_penalty + 1e-9)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.7792,
          "other_inf": null
     },
     {
          "algorithm": "This greedy heuristic selects the next node by finding the unvisited candidate that minimizes the cost of a two-step detour through it to the final destination. The algorithm gives equal priority to the distance from the current node and the distance to the tour's end point, choosing the node that best maintains a compact path.",
          "thought": "This algorithm greedily selects the next node by finding the unvisited node that minimizes the sum of the distance from the current node and the distance to the final destination node, effectively choosing the path with the cheapest detour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_detour_cost = float('inf')\n\n    for node in unvisited_nodes:\n        # Cost to travel from the current node to this candidate node.\n        dist_from_current = distance_matrix[current_node][node]\n        # Cost to travel from this candidate node back to the tour's destination.\n        dist_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate the total detour cost for inserting this node.\n        # This heuristic finds the node that adds the least extra travel\n        # distance to the path from the current node to the destination.\n        detour_cost = dist_from_current + dist_to_destination\n\n        if detour_cost < min_detour_cost:\n            min_detour_cost = detour_cost\n            next_node = node\n            \n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm greedily selects the next node by calculating a weighted score for each unvisited location based on the provided distance matrix. The selection strategy prioritizes the long-term goal by assigning a greater weight (0.6) to the node's proximity to the final destination, while giving a lower weight (0.4) to the immediate distance from the current node. This approach guides the path towards the tour's endpoint, preventing it from choosing a nearby node that leads far away from the ultimate destination.",
          "thought": "This algorithm selects the next node by evaluating a weighted score that considers both the proximity to the current node and the proximity to the final destination node, balancing immediate gain with a long-term goal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    # Define weights for balancing the two distance factors.\n    # A higher weight for the destination encourages a more direct path towards the end.\n    weight_current_to_next = 0.4\n    weight_next_to_destination = 0.6\n\n    for node in unvisited_nodes:\n        # Cost to travel from the current node to this candidate node.\n        dist_from_current = distance_matrix[current_node][node]\n\n        # Cost to travel from this candidate node to the final destination.\n        dist_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate a composite score. This heuristic avoids picking a node that is\n        # close now but very far from the tour's end point.\n        score = (weight_current_to_next * dist_from_current) + (weight_next_to_destination * dist_to_destination)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.454,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic selects the next node by calculating a composite score that gives equal weight to two factors: the immediate travel cost from the current node and the candidate's \"centrality,\" measured as its average distance to all other unvisited nodes. This balanced strategy prioritizes nodes that are not only close but also centrally located relative to the remaining options. The algorithm thereby avoids prematurely visiting an isolated node that would be costly to connect to later in the tour.",
          "thought": "This algorithm selects the next node by balancing the immediate travel cost with a 'centrality' score, which is the candidate node's average distance to all other unvisited nodes, thereby favoring a path that stays central to the remaining locations.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a centrality-based heuristic.\n    This heuristic balances the immediate cost (distance from the current node)\n    with a \"centrality\" measure of the candidate node with respect to all other\n    remaining unvisited nodes. A node is considered more central if its average\n    distance to other unvisited nodes is lower. This strategy avoids committing\n    to an isolated node early in the tour.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Weights to balance immediate cost vs. future centrality.\n    weight_immediate = 0.5\n    weight_centrality = 0.5\n\n    # If only one unvisited node is left, it's the only choice.\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate Cost: The direct distance from the current node.\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # 2. Centrality Cost: The average distance from the candidate node to all\n        #    OTHER remaining unvisited nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        centrality_cost = 0.0\n        if other_unvisited_nodes:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            centrality_cost = total_dist_to_others / len(other_unvisited_nodes)\n\n        # Composite score penalizes nodes that are far from the current node\n        # or far from the \"center of mass\" of the remaining nodes.\n        score = (weight_immediate * immediate_cost) + (weight_centrality * centrality_cost)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.54582,
          "other_inf": null
     }
]