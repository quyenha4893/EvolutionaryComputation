{
     "algorithm": "This heuristic algorithm selects the next node by minimizing a score that prioritizes the short-term greedy distance, controlled by a weight `alpha`. To improve the long-term path, it applies a smaller, `beta`-weighted \"remoteness bonus\" that favors nodes far from both the final destination and the cluster of other unvisited nodes. The node with the lowest combined score is chosen, balancing immediate cost against strategic positioning to prevent costly detours later in the tour.",
     "thought": "This algorithm selects the next node by minimizing a weighted score that balances the short-term gain of a small greedy distance against the long-term cost, which is reduced by visiting nodes that are remote from both the destination and the cluster of other unvisited nodes.",
     "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a weighted linear score that balances\n    the greedy distance against a combined remoteness factor.\n    \"\"\"\n    # Algorithm parameters (weights for the linear combination)\n    alpha = 1.0  # Weight for the greedy distance component\n    beta = 0.5   # Weight for the look-ahead/remoteness bonus\n\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Greedy distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Component 2: Look-ahead based on distance to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Component 3: Look-ahead based on the candidate's average distance\n        # to all other unvisited nodes (its \"remoteness\").\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        remoteness_factor = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # New Equation: A weighted linear combination. A \"bonus\" is given for\n        # visiting remote nodes (a larger look_ahead_factor reduces the score).\n        look_ahead_bonus = dist_from_candidate_to_dest + remoteness_factor\n        \n        score = alpha * dist_to_candidate - beta * look_ahead_bonus\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
     "objective": 6.41205,
     "other_inf": null
}