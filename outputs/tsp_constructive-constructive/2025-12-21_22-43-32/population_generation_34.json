[
     {
          "algorithm": "This heuristic algorithm selects the next node by minimizing a score that prioritizes the short-term greedy distance, controlled by a weight `alpha`. To improve the long-term path, it applies a smaller, `beta`-weighted \"remoteness bonus\" that favors nodes far from both the final destination and the cluster of other unvisited nodes. The node with the lowest combined score is chosen, balancing immediate cost against strategic positioning to prevent costly detours later in the tour.",
          "thought": "This algorithm selects the next node by minimizing a weighted score that balances the short-term gain of a small greedy distance against the long-term cost, which is reduced by visiting nodes that are remote from both the destination and the cluster of other unvisited nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a weighted linear score that balances\n    the greedy distance against a combined remoteness factor.\n    \"\"\"\n    # Algorithm parameters (weights for the linear combination)\n    alpha = 1.0  # Weight for the greedy distance component\n    beta = 0.5   # Weight for the look-ahead/remoteness bonus\n\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Greedy distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Component 2: Look-ahead based on distance to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Component 3: Look-ahead based on the candidate's average distance\n        # to all other unvisited nodes (its \"remoteness\").\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        remoteness_factor = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # New Equation: A weighted linear combination. A \"bonus\" is given for\n        # visiting remote nodes (a larger look_ahead_factor reduces the score).\n        look_ahead_bonus = dist_from_candidate_to_dest + remoteness_factor\n        \n        score = alpha * dist_to_candidate - beta * look_ahead_bonus\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.41205,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a score that balances the immediate greedy cost with a long-term strategic advantage. This look-ahead advantage, calculated as a geometric mean, gives higher priority to nodes that are both far from the final destination and remote from the cluster of other unvisited nodes. The heuristic thereby prioritizes tackling difficult, outlying nodes early in the tour construction.",
          "thought": "This algorithm selects the next node by minimizing a ratio of the immediate travel cost to a look-ahead factor calculated as the geometric mean of the candidate's distance to the destination and its average distance to all other unvisited nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a score that is the ratio of the\n    immediate travel distance to a composite look-ahead factor. This look-ahead\n    factor is the geometric mean of the distance to the final destination and the\n    candidate's remoteness from the cluster of other unvisited nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Greedy distance from the current node (numerator).\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Component 2: Look-ahead based on distance to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Component 3: Look-ahead based on the candidate's average distance to all\n        # other unvisited nodes (its \"remoteness\").\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        remoteness_factor = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # New Equation: The denominator is a geometric mean of the two look-ahead\n        # factors. This balances the need to handle nodes far from the destination\n        # and nodes that are outliers relative to the remaining group.\n        # Small epsilons are added for numerical stability.\n        look_ahead_denominator = math.sqrt(\n            (dist_from_candidate_to_dest + 1e-9) * (remoteness_factor + 1e-9)\n        )\n        \n        score = dist_to_candidate / look_ahead_denominator\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.48831,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines the initial design idea by selecting the next node that minimizes a specific score, calculated as a ratio. The score prioritizes visiting closer nodes (greedy distance in the numerator) but strongly favors those that are also remote from both the final destination and the remaining cluster of unvisited nodes (a combined \"look-ahead\" factor in the denominator). By minimizing this ratio, the heuristic aims to efficiently visit \"outlier\" nodes that are conveniently nearby, addressing them early in the path construction.",
          "thought": "This algorithm selects the next node by minimizing a score that balances the greedy choice of a nearby node against a look-ahead factor combining the node's distance to the final destination and its average distance to all other unvisited nodes.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a score that balances the greedy distance\n    with a look-ahead factor based on remoteness from both the destination and\n    the cluster of other unvisited nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Greedy distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Component 2: Look-ahead based on distance to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Component 3 (Novel Mechanism): Look-ahead based on the candidate's average\n        # distance to all other unvisited nodes (its \"remoteness\").\n        # This helps prioritize visiting \"outlier\" nodes earlier.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        remoteness_factor = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # New Equation: The score is the ratio of the greedy cost to a composite\n        # look-ahead factor. This factor is a sum of the distance to the destination\n        # and the remoteness factor, encouraging visits to nodes that are far\n        # from the end point and also far from the remaining group of nodes.\n        look_ahead_factor = dist_from_candidate_to_dest + remoteness_factor\n        \n        # A small epsilon is added to avoid division by zero.\n        score = dist_to_candidate / (look_ahead_factor + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.5081,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a score that is a ratio of costs to benefits. The cost combines the immediate greedy distance with a penalty for interfering with the most efficient return path, while the benefit is a look-ahead factor that dynamically shifts priority from visiting remote nodes early in the tour to approaching the destination as the tour concludes.",
          "thought": "This algorithm enhances path selection by dynamically adjusting its focus from visiting remote outlier nodes early in the tour to prioritizing a direct return path later, while also penalizing any candidate node that interferes with the most probable penultimate hop to the destination.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a score that dynamically weights remoteness against\n    destination proximity and penalizes interference with the likely return path.\n    \"\"\"\n    total_num_nodes = len(distance_matrix)\n    \n    # If only one unvisited node remains, it must be the next one.\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Greedy cost from the current node.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Define the set of other nodes that would remain if this candidate is chosen.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n\n        # Component 2: Dynamically Weighted Look-Ahead.\n        # This factor balances visiting remote nodes with heading towards the destination.\n        \n        # 2a. Remoteness factor: average distance to other unvisited nodes.\n        remoteness_factor = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # 2b. Proximity to destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n        \n        # 2c. Dynamic weight 'alpha' shifts focus as the tour progresses.\n        # Early in the tour (high alpha), remoteness is prioritized.\n        # Late in the tour (low alpha), destination proximity is prioritized.\n        alpha = len(unvisited_nodes) / total_num_nodes\n        \n        dynamic_look_ahead = (alpha * remoteness_factor) + ((1 - alpha) * dist_from_candidate_to_dest)\n\n        # Component 3 (Novel Mechanism): Return Path Interference Penalty.\n        # This penalizes a candidate if it is positioned poorly relative to the\n        # most likely final segment of the tour.\n        interference_penalty = 0.0\n        if other_unvisited_nodes:\n            # Find the unvisited node (other than the candidate) that is closest to the destination.\n            # This is our \"probable penultimate\" node.\n            penultimate_contender = min(\n                other_unvisited_nodes,\n                key=lambda node: distance_matrix[node][destination_node]\n            )\n            \n            # The penalty is the extra distance incurred by detouring from the candidate\n            # to the destination via this probable penultimate node.\n            penalty_triangle_sides = (distance_matrix[candidate_node][penultimate_contender] + \n                                      distance_matrix[penultimate_contender][destination_node])\n            interference_penalty = penalty_triangle_sides - dist_from_candidate_to_dest\n        \n        # New Equation: The score is a ratio of total \"costs\" to the \"benefit\" of the look-ahead.\n        # Costs include the greedy distance plus the path interference penalty.\n        # The benefit is the dynamically weighted look-ahead score.\n        total_cost_factor = dist_to_candidate + interference_penalty\n        \n        score = total_cost_factor / (dynamic_look_ahead + 1e-9)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    # Fallback in case no node is selected (should not happen if unvisited_nodes is not empty).\n    if next_node is None and unvisited_nodes:\n        return list(unvisited_nodes)[0]\n\n    return next_node",
          "objective": 6.51106,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing the ratio of the immediate travel cost to a strategic look-ahead value. This look-ahead value, heavily weighted by a `beta` parameter, strongly prioritizes visiting \"outlier\" nodes by rewarding candidates that are remote from the cluster of other unvisited nodes and far from the final destination.",
          "thought": "This algorithm enhances the second algorithm's successful look-ahead mechanism by introducing a weighting parameter to more strongly prioritize visiting \"outlier\" nodes, selecting the next node by minimizing the ratio of the greedy travel cost to a new composite look-ahead factor that gives extra emphasis to the candidate's remoteness from the remaining unvisited cluster.",
          "code": "import math\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by enhancing Algorithm 2's score. It introduces a\n    weighting parameter 'beta' to give more importance to the 'remoteness'\n    of a candidate node, thus more aggressively pursuing an \"outlier-first\"\n    strategy.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Beta is a weighting factor that amplifies the importance of a node's\n    # remoteness from the rest of the unvisited cluster. A beta > 1\n    # makes the heuristic more aggressively seek out outliers.\n    beta = 1.75\n\n    for candidate_node in unvisited_nodes:\n        # Numerator: Greedy distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Denominator Component 1: Distance to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Denominator Component 2: Candidate's average distance to all other\n        # unvisited nodes (its \"remoteness\").\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        remoteness_factor = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_factor = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # New Denominator: The look-ahead factor is a weighted sum, with 'beta'\n        # amplifying the remoteness factor. This modification more strongly\n        # favors nodes that are far from the destination AND very far from the\n        # remaining cluster of nodes.\n        look_ahead_factor = dist_from_candidate_to_dest + beta * remoteness_factor\n        \n        # The score is the ratio of the immediate cost to the strategic\n        # look-ahead benefit. A small epsilon avoids division by zero.\n        score = dist_to_candidate / (look_ahead_factor + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.55381,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a score calculated as the ratio of the distance from the current node over the distance to the final destination. This strategy gives high priority to nodes that are close to the current location but far from the final destination. By doing so, the algorithm aims to visit distant nodes early in the tour before moving towards nodes closer to the end point.",
          "thought": "This heuristic algorithm selects the next node by minimizing a ratio that prioritizes nodes closer to the current location over those nearer to the final destination, aiming to visit farther nodes earlier in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing the ratio of the distance from the current node\n    to the distance to the final destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is a ratio of the two distances. This prioritizes visiting\n        # nodes that are close to the current node but relatively far from the\n        # destination, effectively pushing the traversal of distant nodes earlier.\n        # A small epsilon is added to avoid division by zero.\n        score = dist_to_candidate / (dist_from_candidate_to_dest + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node using a hybrid score that is a weighted sum of the simple nearest-neighbor distance and a strategic ratio score (distance to candidate / distance from candidate to destination). By assigning a significantly higher weight to the ratio score via a low `alpha` value, the algorithm prioritizes a globally-aware strategy that considers the final destination. The less-weighted nearest-neighbor distance serves to locally refine this choice, preventing otherwise inefficient jumps.",
          "thought": "My new algorithm selects the next node by calculating a hybrid score that is a weighted sum of the pure nearest-neighbor distance and the superior ratio-based score, primarily relying on the ratio for its strategic advantage while using the nearest-neighbor component to temper the choice and avoid locally inefficient long-distance jumps.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a hybrid score that is a weighted sum of the\n    Nearest Neighbor distance (from Algorithm 2) and the Ratio heuristic (from Algorithm 3).\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # This weighting factor, alpha, balances the two heuristics.\n    # A low alpha gives more weight to the successful Ratio heuristic,\n    # while a high alpha would make it behave more like Nearest Neighbor.\n    alpha = 0.15\n\n    for candidate_node in unvisited_nodes:\n        # Distance from the current node to the candidate (greedy component)\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Distance from the candidate to the final destination (look-ahead component)\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Score component from Nearest Neighbor heuristic (Algorithm 2)\n        nn_score = dist_to_candidate\n\n        # Score component from Ratio heuristic (Algorithm 3)\n        # A small epsilon is added to avoid division by zero.\n        ratio_score = dist_to_candidate / (dist_from_candidate_to_dest + 1e-9)\n\n        # The final score is a weighted combination of the two successful strategies.\n        # This leverages the global path-finding strength of the ratio heuristic\n        # while using the simple NN score to refine the local choice.\n        score = alpha * nn_score + (1 - alpha) * ratio_score\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.66854,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm implements a greedy \"Nearest Neighbor\" heuristic to iteratively construct a tour. At each step, it exclusively prioritizes the distance from the `current_node` to select the absolute closest node from the set of unvisited nodes. The final `destination_node` is passed as a parameter but is completely ignored during this selection process.",
          "thought": "The algorithm greedily constructs a tour by iteratively selecting the closest unvisited node to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by minimizing a strategic score that balances a greedy choice (distance from current node) with a look-ahead penalty (average distance to other unvisited nodes). This score is structured as a ratio that further prioritizes tackling the most distant parts of the tour early by favoring candidate nodes that are far from the final destination.",
          "thought": "This algorithm selects the next node by minimizing a ratio where the numerator is a weighted sum of the distance to the candidate and the candidate's average distance to other unvisited nodes (inspired by algorithm 1), and the denominator is the distance from the candidate to the final destination (inspired by algorithm 2).",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a score that combines ideas from\n    both previous algorithms. The score is a ratio: the numerator is a\n    penalized distance (like algorithm 1) and the denominator is the distance\n    to the destination (like algorithm 2).\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Alpha is a weighting factor for the penalty, balancing the greedy choice\n    # with the strategic goal of staying close to the unvisited cluster.\n    alpha = 0.15\n\n    for candidate_node in unvisited_nodes:\n        # Numerator part 1: Distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Numerator part 2: Penalty based on candidate's distance to other unvisited nodes.\n        other_unvisited = unvisited_nodes - {candidate_node}\n        penalty = 0\n        if other_unvisited:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            penalty = total_dist_to_others / len(other_unvisited)\n        \n        # The numerator combines the greedy choice with the strategic penalty.\n        numerator = dist_to_candidate + alpha * penalty\n\n        # Denominator: Distance from the candidate to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score prioritizes nodes that are strategically attractive (low numerator)\n        # and far from the end point (high denominator), effectively tackling\n        # challenging parts of the tour early.\n        # A small epsilon avoids division by zero.\n        score = numerator / (dist_from_candidate_to_dest + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.28837,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a score that balances three distinct factors. The algorithm provides a strong incentive to visit nodes far from the final destination, while simultaneously penalizing both the immediate travel distance and the candidate node's remoteness from the cluster of other unvisited nodes. This combined score aims to build a wide, sweeping tour that avoids getting trapped in local regions or making costly detours to isolated nodes.",
          "thought": "This algorithm selects the next node by minimizing a weighted score that favors nodes far from the destination but penalizes both the immediate travel distance and the node's remoteness from the remaining cluster of unvisited nodes.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing a score that sums the greedy distance\n    and remoteness penalty, while subtracting a bonus for being far from the destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Component 1: Greedy distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Component 2: Bonus based on distance to the final destination. A larger\n        # distance is better, so it will be subtracted from the score.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Component 3: Penalty based on the candidate's average distance to all\n        # other unvisited nodes (its \"remoteness\"). This discourages visiting\n        # outliers that might create inefficient detours.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        \n        remoteness_penalty = 0.0\n        if other_unvisited_nodes:\n            sum_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            remoteness_penalty = sum_dist_to_others / len(other_unvisited_nodes)\n\n        # New Equation: The score is a linear combination. It sums the greedy\n        # cost and the remoteness penalty, but subtracts the distance to the\n        # destination to prioritize nodes that are \"on the other side\" of the map.\n        # This encourages a broad sweep across the node space early on.\n        score = dist_to_candidate + remoteness_penalty - dist_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.38853,
          "other_inf": null
     }
]