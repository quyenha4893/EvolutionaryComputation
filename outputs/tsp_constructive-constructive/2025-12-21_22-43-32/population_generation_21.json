[
     {
          "algorithm": "This algorithm selects the next node by minimizing a score calculated as the ratio of the distance from the current node over the distance to the final destination. This strategy gives high priority to nodes that are close to the current location but far from the final destination. By doing so, the algorithm aims to visit distant nodes early in the tour before moving towards nodes closer to the end point.",
          "thought": "This heuristic algorithm selects the next node by minimizing a ratio that prioritizes nodes closer to the current location over those nearer to the final destination, aiming to visit farther nodes earlier in the tour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by minimizing the ratio of the distance from the current node\n    to the distance to the final destination.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is a ratio of the two distances. This prioritizes visiting\n        # nodes that are close to the current node but relatively far from the\n        # destination, effectively pushing the traversal of distant nodes earlier.\n        # A small epsilon is added to avoid division by zero.\n        score = dist_to_candidate / (dist_from_candidate_to_dest + 1e-9)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 6.66389,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm implements a greedy \"Nearest Neighbor\" heuristic to iteratively construct a tour. At each step, it exclusively prioritizes the distance from the `current_node` to select the absolute closest node from the set of unvisited nodes. The final `destination_node` is passed as a parameter but is completely ignored during this selection process.",
          "thought": "The algorithm greedily constructs a tour by iteratively selecting the closest unvisited node to the current node.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_distance = float('inf')\n\n    for node in unvisited_nodes:\n        distance = distance_matrix[current_node][node]\n        if distance < min_distance:\n            min_distance = distance\n            next_node = node\n            \n    return next_node",
          "objective": 7.00437,
          "other_inf": null
     },
     {
          "algorithm": "This constructive heuristic modifies the Nearest Neighbor strategy by choosing the next node based on a composite score rather than just distance. The score is primarily determined by the distance from the current node, but a `beta`-weighted penalty is added for candidates that are, on average, far from the remaining unvisited nodes. This approach balances the greedy choice of picking the closest node with the strategic goal of avoiding early moves to isolated points.",
          "thought": "This algorithm enhances the Nearest Neighbor strategy by selecting the closest node while applying a small penalty based on that node's average distance to all other remaining unvisited nodes, thereby balancing the greedy choice with the strategic goal of staying central to the future path.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node by finding the nearest neighbor, but penalizes candidates\n    that are far from the cluster of other remaining unvisited nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Beta is a weighting factor for the penalty. A small value ensures we\n    # prioritize the nearest neighbor aspect but still consider the penalty.\n    beta = 0.25\n\n    for candidate_node in unvisited_nodes:\n        # Primary metric: distance from the current node to the candidate\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # Penalty metric: average distance from the candidate to all *other* unvisited nodes.\n        # This discourages moving to a node that is isolated from the rest.\n        other_unvisited = unvisited_nodes - {candidate_node}\n        penalty = 0\n        if other_unvisited:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n            penalty = total_dist_to_others / len(other_unvisited)\n\n        # The score prioritizes the nearest neighbor but is regularized by the penalty.\n        score = dist_to_candidate + beta * penalty\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.44537,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a score as the product of two key distances: the distance from the current node and the distance to the final destination. By choosing the node with the minimum score, the algorithm gives high priority to candidates that are exceptionally close to either the current position or the tour's end point. This multiplicative approach balances a greedy choice with a strategic move towards completing the tour efficiently.",
          "thought": "This heuristic algorithm selects the next node by calculating a score as the product of the distance from the current node and the distance to the final destination, choosing the node with the minimum score to balance immediate and future costs.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a multiplicative heuristic that balances the distance\n    from the current node and the distance to the final destination node.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is the product of the two distances. This is a different way\n        # to balance the greedy choice (short distance now) against the\n        # strategic choice (not moving too far from the end point).\n        # A small value for either distance will heavily reduce the score.\n        score = dist_to_candidate * dist_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.46224,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score that balances the immediate travel cost from the current node against the future cost of returning to the final destination. The key `alpha` parameter, set to 0.6, controls this balance by giving higher priority to minimizing the immediate travel distance while still factoring in the distance to the final goal. The node with the lowest combined score is chosen as the next step in the path.",
          "thought": "This algorithm selects the next node by balancing the immediate travel cost from the current node with the future cost of returning to the final destination, using a weighted score.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a weighted heuristic that considers both the distance\n    from the current node and the distance to the final destination node.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Alpha is a weighting factor.\n    # alpha = 1.0 behaves like the standard Nearest Neighbor.\n    # alpha = 0.0 would only focus on picking the node closest to the destination.\n    # A value between 0 and 1 balances these two desires.\n    alpha = 0.6\n\n    for candidate_node in unvisited_nodes:\n        # Cost to travel from the current node to the candidate node\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n        \n        # Cost to travel from the candidate node to the final destination\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # The score is a weighted sum of the two distances. This balances the\n        # greedy choice (short distance now) with a more strategic choice\n        # (not moving too far away from the end point).\n        score = alpha * dist_to_candidate + (1 - alpha) * dist_from_candidate_to_dest\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.63302,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm selects the next node by calculating a multiplicative score that combines the immediate travel cost with a penalty representing the candidate's total distance to all other unvisited nodes. By multiplying these factors, the heuristic aggressively penalizes nodes that are either far from the current position or isolated from the remaining cluster of points. This dual-criteria approach prioritizes creating a compact partial tour, aiming to avoid costly detours to isolated nodes later.",
          "thought": "This heuristic algorithm selects the next node by calculating a multiplicative score from two factors: the immediate travel cost and the candidate's total distance to all other unvisited nodes, aggressively penalizing choices that are both far and isolated.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    if len(unvisited_nodes) == 1:\n        return list(unvisited_nodes)[0]\n\n    next_node = None\n    best_score = float('inf')\n\n    for candidate_node in unvisited_nodes:\n        # Factor 1: The immediate cost to travel to the candidate node.\n        immediate_cost = distance_matrix[current_node][candidate_node]\n\n        # Factor 2: An \"outlier\" penalty, measured as the sum of distances\n        # from the candidate to all OTHER unvisited nodes.\n        other_unvisited = unvisited_nodes - {candidate_node}\n        outlier_penalty = sum(distance_matrix[candidate_node][other] for other in other_unvisited)\n        \n        # The multiplicative score heavily penalizes nodes that are poor on either factor.\n        # A small constant is added to the penalty to ensure that the immediate cost\n        # is still a factor even if a node is co-located with all others (penalty=0).\n        score = immediate_cost * (outlier_penalty + 1e-9)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 7.7792,
          "other_inf": null
     },
     {
          "algorithm": "This greedy heuristic selects the next node by finding the unvisited candidate that minimizes the cost of a two-step detour through it to the final destination. The algorithm gives equal priority to the distance from the current node and the distance to the tour's end point, choosing the node that best maintains a compact path.",
          "thought": "This algorithm greedily selects the next node by finding the unvisited node that minimizes the sum of the distance from the current node and the distance to the final destination node, effectively choosing the path with the cheapest detour.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    min_detour_cost = float('inf')\n\n    for node in unvisited_nodes:\n        # Cost to travel from the current node to this candidate node.\n        dist_from_current = distance_matrix[current_node][node]\n        # Cost to travel from this candidate node back to the tour's destination.\n        dist_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate the total detour cost for inserting this node.\n        # This heuristic finds the node that adds the least extra travel\n        # distance to the path from the current node to the destination.\n        detour_cost = dist_from_current + dist_to_destination\n\n        if detour_cost < min_detour_cost:\n            min_detour_cost = detour_cost\n            next_node = node\n            \n    return next_node",
          "objective": 7.99477,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node based on a weighted score that primarily prioritizes the greedy choice of the nearest neighbor (weight 0.5). To improve upon a simple greedy approach, it also incorporates a significant \"look-ahead\" factor measuring cohesion with other unvisited nodes (weight 0.3) and a minor strategic pull towards the final destination (weight 0.2).",
          "thought": "This algorithm selects the next node by evaluating a score that combines the immediate travel cost, the proximity to the nearest subsequent unvisited node, and the distance to the final destination, using a set of three weights to balance these greedy and strategic factors.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a multi-factor heuristic that considers immediate cost,\n    future path cohesion (proximity to other unvisited nodes), and distance to the final goal.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Weights for the three components of the score:\n    # w_immediate: a greedy factor for the cost to the next node.\n    # w_cohesion: looks one step ahead to see if the candidate is close to other unvisited nodes,\n    #             avoiding the creation of isolated, hard-to-reach nodes later.\n    # w_goal: a strategic factor pulling the path towards the final destination.\n    w_immediate = 0.5\n    w_cohesion = 0.3\n    w_goal = 0.2\n\n    for candidate_node in unvisited_nodes:\n        # 1. Immediate cost: Distance from the current node to the candidate.\n        dist_to_candidate = distance_matrix[current_node][candidate_node]\n\n        # 2. Cohesion cost: Distance from the candidate to its nearest unvisited neighbor.\n        # This penalizes moving to a node that is far from all other remaining nodes.\n        min_dist_to_neighbor = float('inf')\n        other_unvisited = unvisited_nodes - {candidate_node}\n        \n        if not other_unvisited:\n            # If the candidate is the last unvisited node, its cohesion cost is zero\n            # as the next step will be the destination.\n            min_dist_to_neighbor = 0\n        else:\n            for neighbor in other_unvisited:\n                dist = distance_matrix[candidate_node][neighbor]\n                if dist < min_dist_to_neighbor:\n                    min_dist_to_neighbor = dist\n        \n        # 3. Goal orientation cost: Distance from the candidate to the final destination.\n        dist_from_candidate_to_dest = distance_matrix[candidate_node][destination_node]\n\n        # Calculate the composite score using the weighted sum of the three factors.\n        score = (w_immediate * dist_to_candidate +\n                 w_cohesion * min_dist_to_neighbor +\n                 w_goal * dist_from_candidate_to_dest)\n        \n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n            \n    return next_node",
          "objective": 8.00509,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm selects the next node by calculating a weighted score for each unvisited candidate, making it a multi-factor greedy selection. The score heavily prioritizes the immediate travel cost (w1=0.5), while strategically tempering this choice by also considering the node's centrality to the remaining cluster of nodes (w3=0.3) and, with the least priority, its distance to the final destination (w2=0.2).",
          "thought": "This heuristic algorithm selects the next node by calculating a score that combines the immediate travel cost with a strategic look-ahead factor, which itself is a weighted average of the candidate's distance to the final destination and its average distance to all other unvisited nodes.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    \"\"\"\n    Selects the next node using a heuristic that balances immediate cost with a\n    more comprehensive look-ahead strategy, considering both the final destination\n    and the cluster of remaining unvisited nodes.\n    \"\"\"\n    next_node = None\n    best_score = float('inf')\n\n    # Weights for the three components of the score.\n    # w1: Weight for the immediate distance (greedy choice).\n    # w2: Weight for the distance to the final destination (long-term goal).\n    # w3: Weight for the average distance to all other unvisited nodes (strategic positioning).\n    w1 = 0.5  # Prioritizes the immediate next step, similar to the better-performing algorithm.\n    w2 = 0.2  # Considers the final destination, but with less weight.\n    w3 = 0.3  # Adds a new strategic factor for how central a node is to the remaining sub-problem.\n\n    for candidate_node in unvisited_nodes:\n        # 1. Cost from the current node to the candidate node.\n        dist_from_current = distance_matrix[current_node][candidate_node]\n\n        # 2. Cost from the candidate node back to the destination.\n        dist_to_destination = distance_matrix[candidate_node][destination_node]\n\n        # 3. Average distance from the candidate to all OTHER unvisited nodes.\n        # This helps select a node that is centrally located to the remaining nodes.\n        other_unvisited_nodes = unvisited_nodes - {candidate_node}\n        if not other_unvisited_nodes:\n            avg_dist_to_others = 0\n        else:\n            total_dist_to_others = sum(distance_matrix[candidate_node][other] for other in other_unvisited_nodes)\n            avg_dist_to_others = total_dist_to_others / len(other_unvisited_nodes)\n\n        # Calculate the composite score.\n        score = (w1 * dist_from_current) + \\\n                (w2 * dist_to_destination) + \\\n                (w3 * avg_dist_to_others)\n\n        if score < best_score:\n            best_score = score\n            next_node = candidate_node\n\n    return next_node",
          "objective": 8.2245,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic algorithm greedily selects the next node by calculating a weighted score for each unvisited location based on the provided distance matrix. The selection strategy prioritizes the long-term goal by assigning a greater weight (0.6) to the node's proximity to the final destination, while giving a lower weight (0.4) to the immediate distance from the current node. This approach guides the path towards the tour's endpoint, preventing it from choosing a nearby node that leads far away from the ultimate destination.",
          "thought": "This algorithm selects the next node by evaluating a weighted score that considers both the proximity to the current node and the proximity to the final destination node, balancing immediate gain with a long-term goal.",
          "code": "def select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    next_node = None\n    best_score = float('inf')\n\n    # Define weights for balancing the two distance factors.\n    # A higher weight for the destination encourages a more direct path towards the end.\n    weight_current_to_next = 0.4\n    weight_next_to_destination = 0.6\n\n    for node in unvisited_nodes:\n        # Cost to travel from the current node to this candidate node.\n        dist_from_current = distance_matrix[current_node][node]\n\n        # Cost to travel from this candidate node to the final destination.\n        dist_to_destination = distance_matrix[node][destination_node]\n\n        # Calculate a composite score. This heuristic avoids picking a node that is\n        # close now but very far from the tour's end point.\n        score = (weight_current_to_next * dist_from_current) + (weight_next_to_destination * dist_to_destination)\n\n        if score < best_score:\n            best_score = score\n            next_node = node\n\n    return next_node",
          "objective": 8.454,
          "other_inf": null
     }
]